\documentclass[12pt,a4paper,oneside,titlepage]{report}

\usepackage{times}
\usepackage[frenchb]{babel}
\usepackage{hyperref} 
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{amsmath} %%
%\usepackage{amsfonts}
%\usepackage{amscd}
%\usepackage{amstext}
\usepackage{amssymb} %%
%\usepackage{bar}
\usepackage{color}
%\usepackage{mathrsfs}
\usepackage{graphicx}
%\usepackage{calligra}
\usepackage{amsthm} % proof
%\usepackage{multirow}
%\usepackage{tabularx}
%\usepackage{layout}
%\pagestyle{headings}
\usepackage{fancyhdr}
\usepackage{pdfpages} %
\usepackage{algorithm} %
\usepackage{algpseudocode} %
\usepackage{makecell} %
\usepackage{tikz} %grahps 
\usetikzlibrary{automata, arrows, positioning, decorations.pathreplacing}
\usepackage{float} %force algorithm in place
\pagestyle{fancy}

%\setlength{\textheight}{630pt}
%\setlength{\footskip}{30pt}
\newtheorem{defi}{D\'efinition}[section]
\newtheorem{note}{Note}[section]
\newtheorem{proprietet}{Propri\'et\'e}[section]
\newtheorem{exemple}{Exemple}[section]
\newtheorem{corollaire}{Corollaire}[section]
\newtheorem{rem}{Remarque}[section]
\newtheorem{thm}{Th\'eor\`eme}[section]
\newtheorem{illustration}{Illustration}[section]
\newenvironment{demonstration}{\begin{proof}[\textnormal{\textbf{Preuve.}}]}{\end{proof}}
\definecolor{gris}{gray}{0.45}
\setlength{\parindent}{1cm}
\newcommand{\textcalli}[1]{{\small{\textbf{$\negmedspace$\calligra #1}}}}

\renewcommand{\chaptermark}[1]{\markright{\thechapter\ #1}}
%\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % supprime les en-têtes et pieds prédéfinis
\fancyhead[R]{\thepage}% Left Even, Right Odd
\fancyhead[L]{\textsl{\leftmark}} % Left Odd
%\fancyhead[RE]{\textsl{\leftmark}} % Right Even
\renewcommand{\headrulewidth}{0pt}% filet en haut de page
\renewcommand{\footrulewidth}{0pt} % pas de filet en bas
\fancypagestyle{plain}{ % pages de tetes de chapitre
\fancyhead{} % supprime lentete
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0pt} % et le filet
}

\newcommand{\unary}[1][1.5ex]{\rule{1pt}{#1}}

\begin{document}
\includepdf{pageGarde.pdf}
%newpage
%\thispagestyle{empty}
%\null
%\newpage
\pagenumbering{roman}
\chapter*{Remerciements}
\renewcommand{\leftmark}{REMERCIEMENTS}
%\addcontentsline{toc}{chapter}{Remerciements}

Nous remercions ...\\

\newpage
\renewcommand{\leftmark}{TABLE DES MATI\`{E}RES}
\thispagestyle{fancy}
\tableofcontents


\newpage
\pagenumbering{arabic}
\renewcommand{\leftmark}{INTRODUCTION}
\chapter{Introduction}
\subsubsection*{Contexte}
\subsubsection*{Définition du problème}
Le probleme dumodel-checking consiste a vérifier qu’un système informatique satisfait une spécification
quand ceux-ci sont donnes sous la forme de modèles mathématiques. Des spècifications typiques sont : est-
ce que le systeme peut atteindre unétat de deadlock ? Est-ce qu’une requète reçoit toujours une reponse ?
Les modeles utilisés peuvent varier : les comportements du système informatique peuventétre modelisè
par un automate acceptant des mots infinis, tandis que la specification peutètre modelisèe par une formule
de logique temporelle LTL.
Plutot que de verifier qu’un système informatique satisfait une spécification, on peut aller plus loin en
envisageant la synthese de controleur. Dans le but de definir les interactions d’un système informatique
avec son environnement, on considere ici un graphe orienté dont les sommets sont partagès entre le système
et l’environnement. Une interaction est alors un chemin infini dans le graphe tel qu’en tout sommet 
systeme (resp. de l’environnement), c’est lui qui décide quel arc suivrea partir de ce sommet. L’objectif
du systeme est, par exemple, d’éviter unètat de deadlock quoique fasse l’environnement, ou encore de
repondrea une requéte quoique fasse l’environnement. Pour y arriver, il a besoin d’une strategie gagnante
qui n’est rien d’autre qu’un programme de controle. La synthese de controleur revient donca construire
(quand c’est possible) une strategie gagnante (contre l’environnement) pour un objectif donnè du système.
Dans ce projet, on propose d’etudier ce problème de synthése pour desjeux de surete´ joues sur graphes.
Pour ces jeux, le systeme a pour objectif d’éviter de passer par certains sommets du graphe.  
\subsubsection*{Présentation et limitations des solutions existantes}
Quand le
graphe est fini, il existe des algorithmes simples qui indiquent si le systeme peut y parvenir et qui dans ce cas
indiquent comment jouer (voir par exemple le livre [1]). Quand le graphe est infini, l’article [2] propose 
algorithme partiel qui utilise des SAT solveurs.
\subsubsection*{Objectif du travail et idées principales}
Dans le cadre du projet, l’etudiant sera amenè´ a comprendre
ces algorithmes et a reproduire les expérimentations de l’article [2], et d’envisager une implèmentation de
calcul de strategie gracea la structure de données “binary decision diagrams” [3,4]
\subsubsection*{Brève description du contenu, chapitre par chapitre}
\newpage

\chapter{Jeux joués sur graphes}\label{ch:1}
\renewcommand{\leftmark}{CHAPITRE \thechapter.~~Jeux joués sur graphes}
Avant de proposer des méthodes de résolution pour les jeux de sûreté, nous allons d'abord introduire les notions liées aux jeux à duration infinie, joués par deux joueurs sur un graphe, les stratégies et nous intéresser à la condition de victoire pour deux types de jeu en particulier : les jeux de sûreté et les jeux d'atteignabilité. 
\section{Arènes}
Une \emph{arène} est un graphe $A = (V_0,V_1,E)$ composé de deux ensembles disjoints, non-vides de sommets $V_0$ et $V_1$, avec $V_0 \cup V_1 = V$, et d'un ensemble d'arcs $E \subseteq V\times V$. De plus, chaque sommet d'une arène doit posséder au moins un successeur.\\

\noindent La figure \ref{fig:arena} représente une arène. Les sommets carrés appartiennent à $V_0$ et les sommets ronds à $V_1$. L'ensemble $E$ correspond aux flèches reliant ces sommets.

\begin{figure}[h]
\centering
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},			
						square/.style = {draw, rectangle, minimum size=10mm}
					]
\node[square] (1) {$1$};
\node[square] (2) [below of=1] {$2$};
\node[round] (3) [right of=1] {$3$};
\node[round] (4) [right of=3] {$4$};
\node[square] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6$};
\node[square] (7) [above of=6] {$7$};
\node[round] (9) [below right of=6] {$9$};
\node[square] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8$};
\node[square] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}
\caption{Exemple d'une arène}
\label{fig:arena}
\end{figure}
\section{Coups, parties et objectifs}
Au début de la partie, un \emph{pion} est placé sur un sommet du graphe. Ce pion est un marquage d'un sommet de l'arène qui va être modifié tour à tour par les joueurs. Dans la suite de ce rapport, \emph{déplacer le pion} référera à l'action de retirer le marquage du sommet courant, et de marquer un autre sommet du graphe.\\
Le jeu est joué par deux \emph{joueurs} numérotés $j_0$ et $j_1$ qui déplacent le pion le long des arcs de l'arène. Le joueur qui déplace le pion est le joueur à qui appartient le sommet courant où se trouve le pion. Un \emph{coup} est l'action d'un joueur de déplacer le pion le long d'un arc du graphe, depuis un sommet lui appartenant, vers un de ses successeurs.\\
Une séquence infinie de coups forme une \emph{partie}.
\begin{defi}
	Une \emph{partie} d'un jeu est une séquence infinie $\pi=v_0 v_1 ...$ où $\forall i\in \mathbb{N},v_i \in V, $ et $(v_i, v_{i+1})\in E$.
\end{defi}
\noindent L'\emph{objectif} $\Omega$ d'un jeu joué sur graphes est ce qui va définir la condition de victoire des joueurs. Dans ce rapport nous allons nous intéresser à deux types de jeux, les jeux de sûreté et les jeux d'atteignabilité. L'objectif pour ces deux types de jeux est défini par un sous ensemble $F\subseteq V$. Dans ces jeux, les deux joueurs jouent selon des objectifs opposés.
\subsection{Jeux de sûreté}
Un jeu de sûreté est défini par un tuple $\mathfrak{G}=(A,I,F)$ avec $A$ une arène, $I\subseteq F$ un ensemble de sommets de départ et $F\subseteq V$ un sous ensemble de sommets dits \emph{sûrs}. L'objectif pour le joueur $j_0$ d'un jeu de sûreté est que tous les sommets visités lors de la partie soient des sommets sûrs. L'objectif pour le joueur $j_1$ est donc qu'au moins un sommet hors de $F$ soit visité.
\begin{defi}
Soit $\mathfrak{G}=(A,I,F)$ un jeu de sûreté, une partie $\pi=v_0v_1...$ est gagnante pour le joueur $j_0$ si $\forall i\in \mathbb{N}, v_i \in F$
\end{defi}
\subsection{Jeux d'atteignabilité}
Un jeu d'atteignabilité est défini par un tuple $\mathfrak{G}=(A,I,F)$ avec $A$ une arène, $I\subseteq V\setminus F$ un ensemble de sommets de départ et $F\subseteq V$ un sous ensemble de sommets \emph{à atteindre}. L'objectif pour le joueur $j_0$ d'un jeu de sûreté est qu'au moins un sommet de $F$ soit visité au cours de la partie. L'objectif du joueur $j_1$ est que seuls des sommets hors de $F$ soient visités.
\begin{defi}
Soit $\mathfrak{G}=(A,I,F)$ un jeu d'atteignabilité, une partie $\pi=v_0v_1...$ est gagnante pour le joueur $j_0$ si $\exists i\in \mathbb{N}, v_i \in F$
\end{defi}
\noindent Les jeux d'atteignabilité sont en dualité avec les jeux de sûreté. En effet, on remarque que l'objectif du joueur $j_0$ (resp. $j_1$) d'un jeu de sûreté est similaire à celui du joueur $j_1$ (resp. $j_0$) pour un jeu d'atteignabilité.

\section{Stratégies et ensembles gagnants}
\noindent Les coups des joueurs sont décidés par la \emph{stratégie} adoptée par ces derniers. Une stratégie est une fonction $s_{j_n} : V^*V_n\to V$ qui indique vers quel sommet le joueur $j_n$ va déplacer le pion depuis le sommet courant $v\in V_n$ selon la séquence de déplacements précédents.\\
Une stratégie peut être \emph{sans mémoire} (ou \emph{positionnelle}) $s_{j_n} : V_n \to V$ si elle ne prend en compte que le sommet actuel où se trouve le pion.\\

\noindent Une stratégie est gagnante \emph{à partir d'un sommet} $v$ si un partie jouée selon cette stratégie 

\begin{defi}
Une partie $\pi=v_0 v_1 ...$ est dite \emph{jouée selon une stratégie} $s_{j_n}$  (à partir d'un sommet $v_0 \in V$) si $\forall i \in \mathbb{N}, v_i \in V_n, v_{i+1} = s_{j_n}(v_0v_1...v_i)$
\end{defi}

\noindent La notion de stratégie gagnante nous permet de définir un \emph{ensemble gagnant}. 
\begin{defi}
\label{finitewinningset}
Soit $\mathfrak{G}=(A,I,F)$ un jeu, avec $A=(V_0, V_1, E)$, l'\emph{ensemble gagnant} pour le joueur $j_n$, $W_n\subseteq V$, est l'ensemble $W_n=\{v\in V$ $|$ $j_n$ possède une stratégie gagnante à partir de $v \}$
\end{defi}


\chapter{Cas fini}
\renewcommand{\leftmark}{CHAPITRE \thechapter.~~Cas fini}
Afin de résoudre les jeux de sûreté joués sur des graphes, nous allons distinguer les arènes possédant un nombre fini de sommets de celles en possèdant un nombre infini. 
\begin{defi}
Une \emph{arène finie} est une arène $A=(V_0, V_1, E)$ pour laquelle $V_0$ et $V_1$ sont des ensembles finis.
\end{defi}
\noindent Dans cette section, nous allons définir la notion d'attracteur, et l'appliquer afin de calculer les ensembles gagnantes des arènes finies, et les stratégies gagnantes des deux joueurs. Nous allons aussi proposer un algorithme qui calcule les attracteurs d'une arène finie.
\section{Résolution via les attracteurs}
Une méthode pour calculer les ensembles gagnants des jeux de sûreté et d'atteignabilité se base sur le principe d'attracteur. 
\begin{defi}
	Soit un jeu $\mathfrak{G} = (A,I,F)$ avec $A=(V_0, V_1, E)$ une arène finie et $F$ un sous-ensemble de sommets, tel que $F\subseteq V$, soit $i\in \mathbb{N}$, le $i^e$ attracteur pour le joueur $j_n$ est l'ensemble :\\
	$Attr_{j_n}^i(F)=\{v\in V$ $|$ le joueur $j_n$ peut forcer une visite d'un sommet de $F
$ depuis $v$ en $ \leq  i $ déplacements$\}$
\end{defi}

%%% INDUCTION ATTRACTEUR
\noindent Afin de construire cet objet en incrémentant la valeur de $i$, \cite{Church} nous donne la formule de construction par induction suivante :
\begin{equation}
\label{eq:induction}
\begin{split}
Attr^0_{j_n}(F)&=F\\
Attr^{i+1}_{j_n}(F)&=Attr^i_{j_n}(F)\\
			&\cup \{v'\in V_n\text{ }|\text{ }\exists(v,v')\in E:v\in Attr^i_{j_n}(F)\}\\
			&\cup \{v'\in V\setminus V_n\text{ }|\text{ }\forall(v,v')\in E:v\in Attr^i_{j_n}(F)\}
\end{split}
\end{equation}
\noindent L'intuition derrière cette formule est la suivante :\\
Initialement, le joueur $j_n$ ne peut forcer une visite d'un sommet de $F$ que depuis un sommet de $F$. On a donc que l'attracteur de départ, $Attr^0_{j_n}(F)$ ne contient que les sommets de $F$.\\
Ensuite, en incrémentant le nombre de coups, autrement dit la valeur de $i$, on va considérer l'ajout des sommets qui sont des prédécesseurs des sommets de l'attracteur courant, car ceux-ci mettront, dans le pire des cas, un coup de plus à atteindre un sommet de $F$. Donc, si un sommet est prédécesseur d'un sommet de l'attracteur sans en faire partie lui-même, il y a deux possibilités (correspondant aux deux ensembles unis à $Attr^i_{j_n}(F)$ dans la formule \ref{eq:induction}). Soit le sommet appartient à $j_n$ et ce sera à lui de jouer un coup à partir de ce sommet. Il pourra ainsi décider de s'approcher d'un sommet de $F$. Il ne faut donc qu'un seul successeur dans l'attracteur courant pour être ajouté à l'attracteur suivant. Par contre si le sommet appartient au joueur opposé à $j_n$, alors il faut s'assurer que peu importe le coup qu'il joue, il se rapproche d'un sommet de $F$. Il est donc nécessaire que tous les successeurs du sommet soient dans $Attr^i_{j_n}(F)$ pour que le sommet soit ajouté à l'attracteur suivant.


Par cette construction, on obtient une séquence d'attracteurs $Attr_{j_n}^0(F)\subseteq Attr_{j_n}^1(F) \subseteq ...$ laquelle sera fixe à partir d'une certaine itération $k\leq|V|$ vu que $V$ est un ensemble fini et qu'à chaque itération, au moins un sommet de $V$ est ajouté à l'attracteur. On notera $Attr_{j_n}(F)=\bigcup_{i=0}^{|V|}Attr_{j_n}^i(F)$

\begin{thm} 
	Pour un jeu d'atteignabilité, cette construction de l'attracteur pour $j_0$ vers $F$ donnera l'ensemble gagnant $W_0$ de $j_0$, ainsi que la stratégie gagnante positionnelle des deux joueurs.
\end{thm}
\begin{demonstration}{
On a que $Attr_{j_0}(F)\subseteq W_0 $ car
\begin{itemize}
\item $\forall v \in Attr_{j_0}^{i+1}\cap V_0, v$ possède un successeur dans $Attr_{j_0}^i$.
\item $\forall v \in Attr_{j_0}^{i+1}\cap V_1,$ tous les successeurs de $v$ sont dans $Attr_{j_0}^i$.
\item $Attr_{j_0}^0(F) \subseteq F$
\end{itemize}
Donc $j_0$ peut gagner la partie à partir de tous les sommets de $Attr_{j_0}(F)$. Sa stratégie gagnante est, pour chaque coup depuis un sommet de $Attr^{i+1}_{j_0}(F)$, de déplacer le pion vers un sommet dans $Attr^{i}_{j_0}(F)$ afin de se rapprocher progressivement de $Attr_{j_0}^0(F) \subseteq F$, ce qui est possible par la manière dont est construit l'attracteur. Cette construction explique aussi que le joueur opposé sera forcé d'en faire autant. Cette stratégie est donc gagnante pour $j_0$ depuis chaque sommet de l'attracteur.\\

\noindent Pour montrer que $W_0\subseteq Attr_{j_0}(F)$, il faut montrer que $j_0$ ne peut pas gagner la partie à partir d'un sommet hors de $Attr_{j_0}(F)$, autrement dit que $j_1$ peut forcer le pion à rester en dehors de $Attr_{j_0}(F)$ depuis tout sommet hors de $Attr_{j_0}(F)$.\\
Soit un sommet $v\in V_1\setminus Attr_{j_0}(F)$, alors $v$ possède au moins un arc $(v, v')$ avec $v'\notin Attr_{j_0}(F)$, sinon on aurait $v \in Attr_{j_0}(F)$. La stratégie gagnante pour $j_1$ dans ce cas est de déplacer le pion le long de cet arc afin de rester hors de l'attracteur.\\
Soit  un sommet $v\in V_0\setminus Attr_{j_0}(F)$, alors tous les arcs $v$
mènent vers un sommet hors de $Attr_{j_0}(F)$, sinon on aurait $v \in Attr_{j_0}(F)$. $j_0$ ne peut donc pas entrer dans l'attracteur depuis ce sommet et ne peut donc pas forcer de visite d'un sommet de $F$ depuis ce sommet. La stratégie gagnante de $j_1$ dans ce cas est de suivre n'importe lequel de ces arcs.
Ces deux cas étant exhaustifs, et ayant montré que $j_0$ est contraint de rester hors de l'attracteur dans ces deux cas, on a bien que $W_0\subseteq Attr_{j_0}(F)$

\noindent L'inclusion étant vérifiée dans les deux sens, on en déduit $W_0 = Attr_{j_0}(F)$.}
\end{demonstration}
\noindent Ces deux cas exhaustifs nous permettent aussi de déduire la stratégie gagnante du joueur $j_1$. A chaque coup, il doit déplacer le pion vers un sommet hors de l'attracteur.

Ainsi nous avons montré que l'on peut construire l'ensemble gagnant $W_0$ du joueur $j_0$ pour un jeu d'atteignabilité en utilisant le principe d'attracteur. On obtient aussi immédiatement l'ensemble gagnant $W_1=V\setminus W_0$ du joueur $j_1$. Chaque joueur peut gagner la partie à partir de chaque sommet de leur ensemble gagnant respectif en adoptant les stratégies énoncées ci-dessus.\\
Ainsi, un jeu de sûreté joué selon ces stratégies sera toujours gagnant pour le joueur $j_0$ si $I\subseteq W_0$.

\noindent De plus, la dualité entre un jeu d'atteignabilité et un jeu de sûreté nous permet d'énoncer le théorème suivant :

\begin{thm}
	Cette méthode de résolution pour les jeux d'atteignabilité permet aussi de résoudre les jeux de sûreté.
\label{thm:dualite}
\end{thm}
\begin{demonstration}
Soit un jeu de sûreté $\mathfrak{G} = (A, F)$ avec $A$ une arène finie. on construit $Attr_{j_1}(V\setminus F)$, autrement dit la liste de sommets depuis lesquels $j_1$ peut forcer une visite d'un sommet hors de $F$. En adoptant la même stratégie que $j_0$ dans un jeu d'atteignabilité, cet attracteur donne l'ensemble gagnant de $j_1$ pour un jeu de sûreté. De manière analogue, $j_0$, en adoptant la stratégie du joueur $j_1$ du jeu d'atteignabilité, ne pourra gagner le jeu de sûreté que depuis les sommets hors de cet attracteur.
\end{demonstration}
\noindent La figure \ref{fig:ensemblegagnant} représente, en gris, l'ensemble gagnant du joueur $j_0$ d'un jeu d'atteignabilité joue sur l'arène de la figure \ref{fig:arena}, avec $F=\{1,2,11\}$.
\begin{figure}[H]
\centering
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3$};
\node[cround] (4) [right of=3] {$4$};
\node[csquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6$};
\node[square] (7) [above of=6] {$7$};
\node[cround] (9) [below right of=6] {$9$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
\caption{Illustration d'un ensemble gagnant}
\label{fig:ensemblegagnant}
\end{figure}
\newpage

\section{Algorithme}
Nous allons maintenant proposer un algorithme de calcul du $i^e$ attracteur. Pour faciliter la lecture, l'algorithme sera découpé en 3 phases suivies d'explications.
%%% ALGO ATTRACTEURS
\begin{algorithm}[H]
\caption{Attracteur}\label{attractor}
\hspace*{\algorithmicindent} 
\begin{tabular}{lll}
	\textbf{Entrées} & \textbf{G} : &Graphe, structure de données composée d'un tableau à deux\\
	&&dimensions $predecessors$ de prédécesseurs (la liste de \\
	&&prédécesseurs d'un noeud $i$ est stockée à la \\
	&&$i^e$ entrée du tableau) et une liste $players$ (le $i^e$ noeud\\
	&&appartient au joueur dont le numéro figure en \\
	&&$i^e$ entrée de $players$).\\
	&\textbf{F} : &Liste de numéros de sommets.\\
	&\textbf{p} : &Numéro de joueur.\\
	&\textbf{i} : &Nombre d'itération pour la construction de\\
	&&l'attracteur, une valeur négative calculera l'attracteur\\
	&&complet.\\
	\textbf{Sortie} &\multicolumn{2}{l}{$Attr_p^i(F)$}\\
\end{tabular}\\
\begin{algorithmic}[1]
\Procedure{Attractor}{$G, F, p, i$}
	\State $out\_degrees \gets$ tableau de taille $|G|$\Comment Pré-traitement
	\For{$j$ allant de 0 à $|G|-1$}
		\If{$G.players[j] \neq p$}
			\For{$pred$ in $G.predecessors[j]$}
				\State $out\_degrees[pred] \gets out\_degrees[pred]+1$
			\EndFor
		\EndIf
	\EndFor
\algstore{attractor}
\end{algorithmic}
\end{algorithm}
L'algorithme commence par une phase de pré-traitement au cours de laquelle on va calculer le \emph{demi-degré extérieur} (le nombre d'arcs sortants) de chaque noeud n'appartenant pas au joueur $p$. Pour cela, on initialise une liste $out\_degrees$ de la taille du nombre de noeuds du graphe. Ensuite, on parcourt le tableau des prédécesseurs du graphe $G.predecessors$. On incrémente l'indice de $out\_degrees$ correspondant à chaque noeud rencontré dans ce tableau car s'il est prédécesseur d'un autre noeud, alors un arc en sort pour aller vers celui-ci.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\algrestore{attractor}
	\State $attractor \gets$ tableau de taille $|G|$\Comment Initialisation
	\For{$index$ in $F$}
		\State $attractor[index] \gets 1$
	\EndFor
	\State $attractor\_new \gets F$
\algstore{attractor}
\end{algorithmic}
\end{algorithm}
On initialise ensuite le tableau $attractor$ qui va indiquer quels sommets sont marqués comme appartenant à l'attracteur courant. On y marque les sommets de $F$. Cette étape correspond au calcul de $Attr^0_p(F)$.\\
On initialise ensuite la liste $attractor\_new$. Cette liste va contenir, après chaque itération de la boucle principale, les sommets qui ont été ajoutés à l'attracteur lors de cette itération. On ajoute initialement les sommets de $F$ à cette liste car $Attr^0_p(F)$ est déjà calculé.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\algrestore{attractor}
	\While{$attractor\_new$ non vide \textbf{and} $i\neq 0$}\Comment Calcul de l'attracteur
		\State $to\_check \gets attractor\_new$
		\State $attractor\_new \gets [$ $]$
		\For{$index$ in $to\_check$}
			\For{$pred$ in $G.predecessors[index]$}
				\If{$attractor[pred] = 0$}
					\If{$G.players[pred] = p$}
						\State $attractor\_new.append(pred)$
					\Else
						\State $out\_degrees[pred]\gets out\_degrees[pred]-1$
						\If{$out\_degrees[pred]=0$}
							\State $attractor\_new.append(pred)$
						\EndIf
					\EndIf
				\EndIf
			\EndFor
		\EndFor
		\For{$index$ in $attractor\_new$}
			\State $attractor[index]\gets 1$
		\EndFor
		\State $i\gets i-1$
	\EndWhile
	\State\Return $attractor$
\EndProcedure
\end{algorithmic}
\end{algorithm}
La première étape de la boucle principale est de copier la liste $attractor\_new$ dans une nouvelle liste $to\_check$ afin de garder une trace des nouveaux sommets à traiter. On vide ensuite la liste $attractor\_new$ afin de pouvoir éventuellement y ajouter des nouveaux sommets pendant l'itération courante. La boucle principale de cet algorithme se base ensuite sur la construction par induction de $Attr_{j_n}(F)$. On y retrouve les 3 éléments de l'union qui constitue $Attr^{i+1}_{j_n}(F)$ dans \ref{eq:induction}:
\begin{itemize}
\item $Attr^i_{j_n}(F)$ se retrouve aux lignes 32-34. A chaque étape, on ne crée pas un nouvel attracteur mais on marque dans $attractor$ les nouveaux sommets présents dans $attractor\_new$.
\item $\{v'\in V_n$ $|$ $\exists(v,v')\in E:v\in Attr^i_{j_n}(F)\}$. Dans la boucle intérieure, lignes 21-22, si un prédécesseur du noeud en cours de traitement appartient au joueur cible, alors il est ajouté à $attractor\_new$ afin d'être ajouté à l'attracteur.
\item $\{v'\in V\setminus V_n$ $|$ $\forall(v,v')\in E:v\in Attr^i_{j_n}(F)\}$. Dans la boucle intérieure, lignes 23-28, si un prédécesseur du noeud en cours de traitement n'appartient pas à $p$, alors il est ajouté à l'attracteur si tous ses successeurs sont aussi dans l'attracteur. C'est à cette étape que le pré-traitement joue un rôle. A chaque fois qu'un noeud est rencontré dans la liste des prédécesseurs d'un autre noeud, on décrémente la valeur correspondante dans $out\_degrees$. Si cette valeur atteint $0$, cela veut dire que tous les successeurs de ce noeud font partie de l'attracteur (car on ne visite les prédécesseurs d'un noeud que s'il a été ajouté à l'attracteur). On peut donc l'ajouter à son tour à l'attracteur.
\end{itemize}
Le calcul s'arrête quand aucun noeud n'est ajouté à l'attracteur au cours d'une itération ($attractor\_new$ est vide). Cela veut dire que le point fixe de la séquence d'attracteur $Attr^0_p(F)\subseteq Attr^1_p(F)\subseteq ...$ est atteint et que l'attracteur complet a été calculé.\\
L'algorithme peut aussi retourner le $i^e$ attracteur si on lui passe en entrée une valeur de $i$ positive (et inférieure au nombre d'itération qu'il faut pour atteindre le point fixe). En effet, $i$ intervient dans le calcul de la condition d'arrêt. Celui-ci est décrémenté à chaque nouvel attracteur calculé. Cependant, la condition d'arrêt ne vérifie qui si $i\neq 0$. Une valeur négative de $i$ en entrée assurera donc le calcul de l'attracteur complet, car celui-ci ne causera pas l'arrêt de la boucle principale.
\subsection{Complexité}
Considérons un graphe $G$ possédant $n$ noeuds et $m$ arcs. Alors l'algorithme \emph{Attractor} possède une complexité dans le pire des cas en $O(n+m)$.
\begin{demonstration}
Afin de calculer la complexité totale de l'algorithme, intéressons-nous à la complexité des 3 étapes principales :
\begin{itemize}
\item \textit{Pré-traitement} (lignes 1-9)\\
Le calcul du demi-degré extérieur à l'aide d'une structure de données telle que décrite dans l'en-tête de l'algorithme se fait en temps $O(m)$. En effet, il s'agit d'itérer sur la liste de prédécesseurs et, pour chaque noeud rencontré, incrémenter son demi-degré extérieur. Le graphe possédant $m$ arcs, il y aura au plus $m$ éléments dans la liste des prédécesseurs. Le coût pour chacun de ces prédécesseurs étant en $O(1)$, la complexité de cette opération sera en $O(m)$.
\item \textit{Initialisation} (lignes 10-14)\\
Cette étape se fait en temps $O(n)$ car il y a au plus $n$ noeuds dans le graphe, donc vers lesquels on souhaite construire l'attracteur. Ainsi, au maximum $n$ opérations en $O(1)$ seront effectuées lors de cette étape.
\item \textit{Calcul de l'attracteur}\\
Considérons une valeur de $i$ négative pour le pire des cas.\\
L'étape du calcul de l'attracteur agit comme un parcours du graphe. En effet, une fois un noeud visité et marqué comme appartenant à l'attracteur, ce noeud ne sera plus visité. Chaque noeud n'est donc visité qu'une seule fois et, dans le pire des cas, tous les noeuds du graphe seront visités.\\
La condition d'arrêt (ligne 15) est vérifiée au maximum $n$ fois (une fois pour chaque sommet, car il faut au minimum un sommet dans $attractor\_new$ pour satisfaire la condition et, dans le pire des cas, tous les sommets seront ajoutés un par un à l'attracteur). Le coût de cette évaluation est $O(1)$.\\
Pour chaque sommet traité, on effectue une action en $O(1)$ (ligne 19) afin de récupérer la liste des ses prédécesseurs dans la structure de données $G$, une autre opération en $O(1)$ (lignes 32-34) afin de marquer ce sommet dans l'attracteur. En comptant aussi la condition d'arrêt et l'opération arithmétique (ligne 35), le coût total par sommet est donc $O(1)$.\\
Ensuite, pour chaque prédécesseur (autrement dit pour chaque arc), l'algorithme n'effectue que des opérations en $O(1)$ : ajouts à une liste (lignes 22 et 26), accès à un tableau via l'indice, comparaisons et opérations arithmétiques (lignes 20, 21, 24 et 25). Le coût total par arc est donc $O(1)$. Nous obtenons un coût total pour le parcours de $n\cdot O(1)+m\cdot O(1) = O(n+m)$.\\
Il faut ajouter à cela le coût de copier la liste $attractor\_new$ dans $to\_check$. Etant donné que cette liste ne peut contenir qu'une fois chaque sommet à travers toutes les itérations, le coût total des copies vaudra $O(n)$. La complexité de l'étape de calcul est donc $O(n+m+n)=O(n+m)$.
\end{itemize}
Nous obtenons donc une complexité totale de $O(n+m+(n+m)) = O(2(n+m))\\
= O(n+m)$.
\end{demonstration}
\newpage
\subsection{Exemple}
Afin d'illustrer le fonctionnement de l'algorithme, considérons l'arène de la figure \ref{fig:arena} et calculons l'attracteur pour le joueur $j_0$ avec  $F=\{1,2,11\}$, dans le but de calculer les ensembles gagnants des deux joueurs pour un jeu d'atteignabilité. Supposons $i$ négatif afin de calculer l'attracteur complet.\\
L'étape de pré-traitement sera rendue visuelle en ajoutant aux noeuds de $j_1$ la valeur correspondant dans le tableau $out\_degrees$. Les noeuds faisant partie de l'attracteur courant $attractor$ seront colorés en gris et ceux étant ajoutés à l'attracteur à l'itération précédente (les noeuds de la liste $attractor\_new$) seront entourés en rouge.
Nous obtenons donc, avant l'entrée dans la boucle principale de l'algorithme, la représentation suivante :\\

%%% ATTR0
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[bcsquare] (1) {$1$};
\node[bcsquare] (2) [below of=1] {$2$};
\node[round] (3) [right of=1] {$3(2)$};
\node[round] (4) [right of=3] {$4(3)$};
\node[square] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(4)$};
\node[square] (7) [above of=6] {$7$};
\node[round] (9) [below right of=6] {$9(2)$};
\node[square] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[bcsquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
Nous avons donc bien $Attr_{j_0}^0(F)=\{1,2,11\}$.\\
La première itération du calcul de l'attracteur va ajouter les noeuds $3$ et $10$ à l'attracteur. En effet, la valeur de $out\_degrees$ de $3$ va être décrémentée deux fois, une fois en suivant les prédécesseurs de $1$ et une autre fois en suivant ceux de $2$. Cette valeur atteignant $0$, il sera ajouté à l'attracteur. La valeur de $out\_degrees$ de $4$ sera aussi décrémentée une fois en partant de $1$. Le cas de $10$ est plus trivial, il appartient à $j_0$ et a été rencontré en suivant les prédécesseurs de $11$, il est donc ajouté à l'attracteur. La valeur de $out\_degrees$ de $9$ est elle aussi décrémentée car le noeud $9$ est un prédécesseur de $11$. Nous obtenons donc la représentation suivante :\\

%%% ATTR1
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[bcround] (3) [right of=1] {$3(0)$};
\node[round] (4) [right of=3] {$4(2)$};
\node[square] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(4)$};
\node[square] (7) [above of=6] {$7$};
\node[round] (9) [below right of=6] {$9(1)$};
\node[bcsquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
On a $Attr_{j_0}^1(F)=\{1,2,3,10,11\}$.\\
$5$ possède maintenant un successeur dans l'attracteur, il y sera donc ajouté à l'étape suivante. La valeur de $out\_degrees$ de 4 est décrémentée une fois, car il est prédécesseur de $3$. Le noeud $9$ est atteint une deuxième fois, cette fois depuis $10$. Sa valeur de $out\_degrees$ passant à 0, il est ajouté à l'attracteur.\\
%%% ATTR2
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3(0)$};
\node[round] (4) [right of=3] {$4(1)$};
\node[bcsquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(4)$};
\node[square] (7) [above of=6] {$7$};
\node[bcround] (9) [below right of=6] {$9(0)$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
Nous obtenons $Attr_{j_0}^2(F)=\{1,2,3,5,9,10,11\}$\\
$4$ est atteint une dernière fois car il est prédécesseur de $5$. Sa valeur de $out\_degree$ passant à 0, il est ajouté à l'attracteur. Cette même valeur pour $6$ est décrémentée deux fois lors de cette itération car il est successeur de $5$ et $9$.\\
%%% ATTR3
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3(0)$};
\node[bcround] (4) [right of=3] {$4(0)$};
\node[csquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(2)$};
\node[square] (7) [above of=6] {$7$};
\node[cround] (9) [below right of=6] {$9(0)$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
On obtient $Attr_{j_0}^3(F)=\{1,2,3,4,5,9,10,11\}$\\
La valeur de $out\_degrees$ de $6$ est décrémentée une fois car il est prédécesseur de $4$. Aucun noeud n'est ajouté à $attractor\_new$, l'algorithme s'arrête.\\
%ATTR4
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3$};
\node[cround] (4) [right of=3] {$4$};
\node[csquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6$};
\node[square] (7) [above of=6] {$7$};
\node[cround] (9) [below right of=6] {$9$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
L'attracteur final calculé par l'algorithme est donc $Attr_{j_0}^4(F)=Attr_{j_0}^3(F)=Attr_{j_0}(F)=\{1,2,3,4,5,9,10,11\}$\\

\noindent Cet attracteur correspond à l'ensemble gagnant $W_0$ du joueur $j_0$. Par exemple, si le pion est initialement placé sur le sommet $5$, ce sera à $j_0$ de le déplacer. Selon la stratégie gagnante pour le joueur $j_0$ décrite dans la section précédente, celui-ci déplacera le pion vers $3$. Le coup suivant sera décidé par le joueur $j_1$. celui-ci n'aura pas le choix et devra déplacer le pion sur un sommet de $F$ : $1$ ou $2$. Le joueur $j_0$ gagne la partie.\\ L'ensemble $W_1=\{6,7,8\}$ est donc l'ensemble gagnant du joueur $j_1$. Si le pion est initialement placé sur un sommet de cet ensemble, alors $j_1$ gagne. Par exemple, le pion placé initialement sur $6$ sera déplacé par le joueur $j_1$ vers $7$ (en passant éventuellement par $8$ selon la stratégie gagnante pour le joueur $j_1$ car ni $7$ ni $8$ ne font partie de l'attracteur). Le joueur $j_0$ déplacera le pion de $7$ vers $6$ et la partie consistera en une répétition infinie de coups entre $6$, $7$ et $8$.\\




\chapter{Cas infini}
Résoudre les jeux de sûreté joués sur des \emph{arènes infinies} va nécessiter une étape d'abstraction. En effet, un algorithme linéaire en terme d'arcs et de sommets aurait une complexité infinie sur un graphe de taille infinie. Nous allons donc, dans ce chapitre, introduire et utiliser des notions de la théorie des automates afin de produire un problème de taille finie, et ensuite proposer des algorithmes de programmation logique afin de résoudre celui-ci.
\begin{defi}
Une \emph{arène infinie} est une arène $A=(V_0, V_1, E)$ pour laquelle on autorise $V_0$ et $V_1$ à être des ensembles infinis.
\end{defi}

\section{Alphabets, automates et transducteurs}
Un \emph{alphabet} $\Sigma$ est un ensemble fini, non vide, de symboles. Un \emph{mot} de longueur $n\in\mathbb{N}$ sur l'alphabet $\Sigma$ est une séquence de symboles $u=u_1u_2...u_n$ avec $\forall i\in\mathbb{N}, u_i\in \Sigma$. Le mot vide est noté $\epsilon$.\\
La \emph{concaténation} de deux mots $u=u_1u_2...u_n$ et $v=v_1v_2...v_m$, avec $n,m\in\mathbb{N}$ est le mot $w=u\cdot v=u_1u_2...u_nv_1v_2...v_m$ de longueur $n+m$. L'ensemble $\Sigma^*$ contient tous les mots possibles sur l'alphabet $\Sigma$.\\
Un \emph{facteur} $v\in\Sigma^*$ d'un mot $u\in\Sigma^*$ est un mot tel que $\exists w_1,w_2\in\Sigma^*,w_1vw_2=u$.\\
Un \emph{préfixe} $v\in\Sigma^*$ d'un mot $u\in\Sigma^*$ est un mot tel que $\exists w\in\Sigma^*, vw=u$.\\
Un sous-ensemble $L\subseteq \Sigma^*$ est appelé un langage.
\begin{defi}
L'ensemble des préfixes d'un langage $L\subseteq\Sigma^*$ est l'ensemble $Pref(L)=\{u\in\Sigma^*$ $|$ $\exists v\in\Sigma^*, uv\in L\}$.
\end{defi}

\noindent Un \emph{automate} fini est un 5-uple $\mathcal{A}=(Q,\Sigma,\delta,q_0,F)$ où 
\begin{itemize}
	\item $Q$ est un ensemble fini, non vide, d'états.
	\item $\Sigma$ est l'alphabet lu par l'automate.
	\item $\delta$ est une fonction $Q\times\Sigma\to Q$ appelée \emph{fonction de transition} de l'automate. L'expression $\delta(q_1,u)=q_2$ indique que l'automate transitionne de l'état $q_1$ à l'état $q_2$ quand le mot $u\in\Sigma^*$ est lu depuis l'état $q_1$.
	\item $q_0\subseteq Q$ est l'ensemble des états initiaux.
	\item $F\subseteq Q$ est l'ensemble des états finaux.
\end{itemize}
\begin{defi}[Automate fini déterministe (AFD)]
\label{deter}
Un automate $\mathcal{A}=(Q,\Sigma,\delta,q_0,F)$ est \emph{déterministe} si $\forall q,p_1,p_2\in Q, a\in\Sigma^*, \delta(q,a)=p_1$ et $\delta(q,a)=p_2$ implique que $p_1=p_2$.
\end{defi}
Un automate fini qui n'est pas déterministe est appelé \emph{automate fini non déterministe (AFN)}.\\

\noindent Un \emph{parcours} d'un automate par un mot $u=u_1u_2...u_n$, $n\in\mathbb{N}$ est une séquence d'états $q_0q_1...q_n$ telle que $\forall i\in\mathbb{N}, \delta(q_i,u_i)=q_{i+1}$. Un mot $u$ est \emph{accepté} par un automate $\mathcal{A}$ si le parcours de l'automate par ce mot se termine sur un état final $q\in F$. L'ensemble des mots acceptés par un automate forme le langage $\mathcal{L}(\mathcal{A})$ de cet automate. Un langage $L$ est dit \emph{régulier} s'il existe un automate fini $\mathcal{A}$ tel que $\mathcal{L}(\mathcal{A})=L$.\\


\noindent Enfin, un \emph{transducteur} est un automate fini non déterministe $\mathcal{T}=(Q,\hat{\Sigma},\delta,q_0,F)$ où $\hat{\Sigma}=(\Sigma\cup\{\epsilon\})\times(\Gamma\cup\{\epsilon\})$ avec $\Sigma$ et $\Gamma$ deux alphabets. Un parcours d'un transducteur ne se fait pas par un mot mais par une paire de mots $(u,v)$ avec $u\in\Sigma^*$ et $v\in\Gamma^*$ afin de produire une séquence $q_0q_1...q_n$, $n\in\mathbb{N}$ telle que $\forall i\in\mathbb{N}, \delta(q_i,(u_i,v_i))=q_{i+1}$. Les mots $u$ et $v$ peuvent être de longueur différente car $\epsilon$ est inclu aux deux alphabets.\\
Un transducteur, en acceptant des paires de mots, permet de définir une \emph{relation} $R$ entre deux langages. L'ensemble des paires de mots acceptées par un transducteur forme la relation $\mathcal{R}(\mathcal{T})$ de ce transducteur. Une relation est dite \emph{régulière} s'il existe un transducteur $\mathcal{T}$ tel que $\mathcal{R}(\mathcal{T})=R$.
\begin{defi}[Image d'une relation]
Soit $\mathcal{T}$ un transducteur acceptant la relation $R$ sur $\hat{\Sigma}=(\Sigma\cup\{\epsilon\})\times(\Gamma\cup\{\epsilon\})$ et $\mathcal{A}$ un AFN, alors\\ $\mathcal{R}(\mathcal{T})(\mathcal{L}(\mathcal{A}))=\{v\in\Gamma^*$ $|$ $\exists u\in\Sigma^*, (u,v)\in\mathcal{R}(\mathcal{T})\}$ est l'image du langage $\mathcal{L}(\mathcal{A})$ par la relation $R$.
\end{defi}
\begin{defi}[Inverse d'une relation]
Soit $\mathcal{T}=(Q,\hat{\Sigma},\delta,q_0,F)$ un transducteur acceptant la relation $R$. On définit l'inverse de $R$ par $R^{-1}=\{(u,v)$ $|$ $(v,u)\in R\}$, la relation que l'on obtient en échangeant tous les éléments des paires de $R$.
\end{defi}

\section{Exemple de jeu de sûreté infini}
Afin d'illustrer le cas infini, nous allons considérer l'arène infinie simple représentée à la figure \ref{fig:infinite-arena}. Il s'agit d'un tableau infini, à une dimension, fermé à gauche. Chaque sommet est décrit par le numéro du joueur à qui il appartient, et un nombre $k\in\mathbb{N}$. Il existe un sommet appartenant à chaque joueur pour chaque valeur possible de $k$ et ceux-ci sont arrangés dans l'ordre croissant de cette valeur, en alternant les sommets de $j_0$ et $j_1$. L'ensemble $F$ est représenté par les sommets grisés. Il est décrit par une certaine valeur non nulle de $k$, à partir de laquelle tous les sommets font partie de $F$ (à la figure \ref{fig:infinite-arena}, $k=2$).

\begin{figure}[H]
\centering
\begin{tikzpicture}[
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						noround/.style = {circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
					]
					
\node[square] (1) {($j_1$,$0$)};
\node[round] (2) [right of=1] {($j_0$,$0$)};
\node[square] (3) [right of=2] {($j_1$,$1$)};
\node[round] (4) [right of=3] {($j_0$,$1$)};
\node[csquare] (5) [right of=4] {($j_1$,$2$)};
\node[cround] (6) [right of=5] {($j_0$,$2$)};
\node[csquare] (7) [right of=6] {($j_1$,$3$)};
\node[noround] (8) [right of=7] {...};

\draw[->] (1) to [out=30,in=150] (2);
\draw[->] (2) to [out=210,in=330] (1);
\draw[->] (2) to [out=30,in=150] (3);
\draw[->] (3) to [out=210,in=330] (2);
\draw[->] (3) to [out=30,in=150] (4);
\draw[->] (4) to [out=210,in=330] (3);
\draw[->] (4) to [out=30,in=150] (5);
\draw[->] (5) to [out=210,in=330] (4);
\draw[->] (5) to [out=30,in=150] (6);
\draw[->] (6) to [out=210,in=330] (5);
\draw[->] (6) to [out=30,in=150] (7);
\draw[->] (7) to [out=210,in=330] (6);
\draw[->] (7) to [out=30,in=150] (8);
\draw[->] (8) to [out=210,in=330] (7);

\end{tikzpicture}
\caption{Exemple d'arène infinie}
\label{fig:infinite-arena}
\end{figure}
\noindent Nous appellerons le jeu joué sur cette arène $\mathfrak{G}_k$. Les règles du jeu sont différentes pour cet exemple. Les joueurs bougent le pion chacun à leur tour. Le joueur $j_0$ ne peut déplacer le pion que vers la droite ou ne pas le déplacer du tout, et le joueur $j_1$ ne peut le déplacer que vers la gauche (s'il n'est pas arrivé au bout de l'arène) ou ne pas le déplacer. Au début de la partie, le pion est placé sur un sommet appartenant à $F$, et le joueur $j_0$ commence. Les objectifs des joueurs restent les mêmes, $j_0$ veut rester dans $F$ tandis que $j_1$ essaie d'en sortir. Cet exemple est simple car le joueur $j_0$ peut gagner, peu importe $F$, en choisissant de bouger le pion à droite à chaque coup. Il reste néanmoins intéressant à résoudre.

\section{Jeux de sûreté rationnels}
Un jeu de sûreté rationnel est une représentation symbolique d'un jeu de sûreté, basée sur les langages rationnels et les relations rationnelles.
\begin{defi}
Une \emph{arène rationelle} sur l'alphabet $\Sigma$ est une arène $A_\Sigma=(V_0,V_1,E)$ où $V_0,V_1$ sont des langages réguliers et $E$ est une relation régulière.
\end{defi}

\begin{defi}
Un \emph{jeu de sûreté rationnel} sur l'alphabet $\Sigma$ est un jeu $\mathfrak{G}_\Sigma=(A_\Sigma, I, F)$ où $A_\Sigma$ est une arène rationnelle sur $\Sigma$ et $I,F\subseteq \Sigma^*$ sont des langages réguliers.
\end{defi}
\noindent Nous allons maintenant traduire le jeu $\mathfrak{G}_k$ en un jeu de sûreté rationnel. Pour cela, nous devons proposer un encodage qui fait correspondre à chaque arc et chaque sommet un mot unique d'un alphabet. Pour cela, nous allons considérer l'alphabet $\Sigma=\{j_0,j_1,\unary\}$ afin d'associer le sommet $(x,i) \in \{j_0,j_1\}\times\mathbb{N}$ au mot $x\unary^i$ où $\unary^i$ est l'encodage de $i$ en unaire. 

\noindent Ainsi, les automates suivants représentent les ensembles $V_0$ et $V_1$ :

\begin{figure}[H]
\centering
\begin{minipage}[b]{0.35\textwidth}
\begin{tikzpicture} [
						node distance=2cm, 
						auto,
						every initial by arrow/.style={->}
					]
					
\node (1) [state, initial, initial text=] {};
\node (2) [state, accepting, right of=1] {};
\node (0) [left of=1] {$\mathcal{A}_{V_0}$ :};

\path[->]
	(1) edge node {$j_0$}   (2)
	(2) edge [loop right] node {$\unary$} ();
\end{tikzpicture}
\end{minipage}
\hfill
\begin{minipage}[b]{0.45\textwidth}
\begin{tikzpicture} [
						node distance=2cm, 
						auto,
						every initial by arrow/.style={->}
					]
					
\node (1) [state, initial, initial text=] {};
\node (2) [state, accepting, right of=1] {};
\node (0) [left of=1] {$\mathcal{A}_{V_1}$ :};

\path[->]
	(1) edge node {$j_1$}   (2)
	(2) edge [loop right] node {$\unary$} ();
\end{tikzpicture}
\end{minipage}
%\caption{Représentation rationelle des ensembles $V_0$ et $V_1$ de $\mathfrak{G}_k$.}
\end{figure}
\noindent Les arcs (l'ensemble $E$) sont représentés par le transducteur suivant 
\begin{figure}[H]
\centering
\begin{tikzpicture} [
						node distance=2.5cm, 
						auto,
						every initial by arrow/.style={->}
					]
					
\node (1) [state, initial above, initial text=] {};
\node (2) [state, accepting, right of=1] {};
\node (3) [state, accepting, left of=1] {};
\node (4) [state, accepting, right of=2] {};
\node (5) [state, accepting, left of=3] {};
\node (0) [left of=5, xshift=1cm] {$\mathcal{T}_E$ :};

\path[->]
	(1) edge node {$(j_0,j_1)$}   (2)
	(1) edge node[anchor=south] {$(j_1,j_0)$}   (3)
	(2) edge [loop above] node {$(\unary,\unary)$} ()
	(3) edge [loop above] node {$(\unary,\unary)$} ()
	(2) edge node {$(\epsilon,\unary)$} (4)
	(3) edge node[anchor=south] {$(\unary,\epsilon)$} (5);
\end{tikzpicture}
%\caption{Représentation rationelle de l'ensemble $E$ de $\mathcal{G}_k$.}
\end{figure}

\noindent Et pour finir, les automates $\mathcal{A}_F$ et $\mathcal{A}_I$ représentent les ensembles $F$ et $I$.
\begin{figure}[h!]
\centering
\begin{tikzpicture} [
						node distance=2cm, 
						auto,
						every initial by arrow/.style={->},
						noround/.style = {circle, minimum size=12mm}
					]
\node (1) [state, initial, initial text=] {};
\node (2) [state, xshift=0.5cm, right of=1] {};
\node[noround] (3) [right of=2] {...};
\node (4) [state, right of=3] {};
\node (5) [state, accepting, right of=4] {};
\node (0) [left of=1] {$\mathcal{A}_F$ :};




\path[->]
	(1) edge node {$(j_0,j_1)$} (2)
	(2) edge node {$\unary$} (3)
	(3) edge node {$\unary$} (4)
	(4) edge node {$\unary$} (5)
	(5) edge [loop right] node {$\unary$} ();
	
\draw[decorate, decoration={brace, mirror, amplitude=5pt},] ([yshift=-0.75cm]2.center)--([yshift=-0.75cm]4.center) node[pos=0.5, below=0.2cm]{$k$ états};
\end{tikzpicture}
%\caption{Représentation rationelle de l'ensemble $F$ de $\mathfrak{G}_k$.}
\end{figure}

\begin{figure}[h!]
\centering
\begin{tikzpicture} [
						node distance=2cm, 
						auto,
						every initial by arrow/.style={->},
						noround/.style = {circle, minimum size=12mm}
					]
\node (1) [state, initial, initial text=] {};
\node (2) [state, right of=1] {};
\node[noround] (3) [right of=2] {...};
\node (4) [state, right of=3] {};
\node (5) [state, accepting, right of=4] {};
\node (0) [left of=1] {$\mathcal{A}_I$ :};




\path[->]
	(1) edge node {$j_0$} (2)
	(2) edge node {$\unary$} (3)
	(3) edge node {$\unary$} (4)
	(4) edge node {$\unary$} (5)
	(5) edge [loop right] node {$\unary$} ();
	
\draw[decorate, decoration={brace, mirror, amplitude=5pt},] ([yshift=-0.75cm]2.center)--([yshift=-0.75cm]4.center) node[pos=0.5, below=0.2cm]{$k$ états};
\end{tikzpicture}
%\caption{Représentation rationelle de l'ensemble $I$ de $\mathfrak{G}_k$.}
\end{figure}


\section{Apprentissage}\label{sectionapprentissage}
Résoudre un jeu de sûreté rationnel consiste à produire un AFD qui acceptera tous les mots représentant les sommets de l'ensemble gagnant $W_0$. Afin de produire un tel automate, nous allons utiliser le principe d'\emph{apprentissage}. Cet apprentissage à lieu entre un \emph{enseignant}, lequel est en connaissance du jeu de sûreté que l'on veut résoudre, et un \emph{élève}, cherchant à en apprendre l'AFD décrivant l'ensemble gagnant. On suppose que l'alphabet utilisé est connu à l'avance par les deux partis\\

Avant de commencer l'apprentissage, \cite{NeiderAutomaton} suggère d'apporter quelques précisions à la définition \ref{finitewinningset} d'ensemble gagnant.
\begin{defi}
\label{infinitewinningset}
Soit $\mathfrak{G}=(A,I,F)$ un jeu, avec $A=(V_0, V_1, E)$, l'\emph{ensemble gagnant} pour le joueur $j_0$ est l'ensemble $W\subseteq V$ qui satisfait :
\begin{itemize}
\item (1) $I\subseteq W$ (\emph{sommets initiaux})
\item (2) $W\subseteq F$ (\emph{sommets sûrs})
\item (3) $\forall v\in W\cap V_0,$ $Succ(v)\cap W\neq\emptyset$ (\emph{fermeture existentielle})
\item (4) $\forall v\in W\cap V_1,$ $Succ(v)\subseteq W$ (\emph{fermeture universelle})
\end{itemize}
Où \emph{Succ($v$)} est la fonction retournant les successeurs du sommet $v$.
\end{defi}
L'apprentissage se fait à l'intérieur d'une boucle de type \emph{CEGIS} (Counter-example guided inductive synthesis, ou synthèse inductive guidée par le contre-exemple). A chaque itération de cette boucle, l'élève conjecture un AFD $\mathcal{C}$ et l'enseignant vérifie à l'aide de la définition \ref{infinitewinningset} si $\mathcal{L}(\mathcal{C})$ est un ensemble gagnant. Si c'est le cas l'enseignant répond "\emph{oui}" et l'apprentissage s'arrête. Sinon, l'enseignant retourne un \emph{contre-exemple} pour une des règles non respectées de la définition \ref{infinitewinningset} et l'apprentissage se poursuit dans l'itération suivante. Plus formellement, la définition suivante établit le protocole de vérification par l'enseignant :
\begin{defi}{Enseignant pour jeux de sûreté rationnels\\}
\label{teacher}
Soit $\mathfrak{G}_\Sigma=(A_\Sigma, I, F)$, un jeu de sûreté rationnel sur $\Sigma$, avec $A_\Sigma=(V_0,V_1,E)$. Soit un AFD $\mathcal{C}$. Un enseignant pour $\mathfrak{G}_\Sigma$ confronté à $\mathcal{C}$ va effectuer les vérifications suivantes :\\
\begin{itemize}
\item (1) Si $I\nsubseteq \mathcal{L}(\mathcal{C})$, alors l'enseignant retourne un \emph{contre-exemple positif} $u\in I\setminus \mathcal{L}(\mathcal{C})$. Sinon,
\item (2) Si $\mathcal{L}(\mathcal{C}) \nsubseteq F$, alors l'enseignant retourne un \emph{contre-exemple négatif} $u\in \mathcal{L}(\mathcal{C})\setminus F$. Sinon, 
\item (3) Si $\exists u\in \mathcal{L}(\mathcal{C})\cap V_0,$ $Succ(u)\cap \mathcal{L}(\mathcal{C})=\emptyset$ alors l'enseignant choisit ce $u$ et retourne un \emph{contre-exemple d'implication existentielle} $(u, \mathcal{A})\in \Sigma^* \times AFN_\Sigma$ où $\mathcal{L}(\mathcal{A})=Succ(u)$. Sinon, 
\item (4) Si $\exists u\in \mathcal{L}(\mathcal{C})\cap V_1,$ $Succ(u)\nsubseteq \mathcal{L}(\mathcal{C})$, alors l'enseignant choisit ce $u$ et retourne un \emph{contre-exemple d'implication universelle} $(u, \mathcal{A})\in \Sigma^* \times AFN_\Sigma$ où $\mathcal{L}(\mathcal{A})=Succ(u)$.
\end{itemize}
Où 
\begin{itemize}
\item $AFN_\Sigma$ est l'ensemble des automates finis non-déterministes sur $\Sigma$.
\item Un \emph{contre-exemple positif} est un mot $u$ qui devrait être accepté par $\mathcal{C}$, mais qui a été rejeté.
\item Un \emph{contre-exemple négatif} est un mot $u$ qui devrait être rejeté par $\mathcal{C}$, mais qui a été accepté.
\item Un \emph{contre-exemple d'implication existentielle} $(u, \mathcal{A})$ signifie que si $\mathcal{C}$ accepte $u$, alors au moins un mot $v \in \mathcal{L}(\mathcal{A})$ doit, lui aussi, être accepté, et cela n'a pas été respecté.
\item Un \emph{contre-exemple d'implication universelle} $(u, \mathcal{A})$ signifie que si $\mathcal{C}$ accepte $u$, alors tous les mots $v \in \mathcal{L}(\mathcal{A})$ doivent, eux aussi, être acceptés, et cela n'a pas été respecté.\\
\end{itemize}
\noindent Si les 4 vérifications ne retournent pas de contre-exemples, alors l'enseignant répond "\emph{oui}".\\
L'ordre des vérifications n'a pas d'importance.
\end{defi}
Afin de se souvenir de ces contre-exemples, l'élève les enregistre dans un \emph{échantillon}, lequel est un 4-uple $S=(Pos, Neg, Ex, Uni)$ composé de 4 ensembles finis. L'ensemble $Pos$ (resp. $Neg$) $\subset\Sigma^*$ contient les contre-exemples positifs (resp. négatifs), et l'ensemble $Ex$ (resp. $Uni$) $\subset(\Sigma^*\times AFN_\Sigma)$ contient les contre-exemples d'implication existentielle (resp. universelle).
\begin{defi}
Un échantillon $S=(Pos, Neg, Ex, Uni)$ est \emph{sans contradictions} si \begin{enumerate}
\item $Pos\cap Neg=\emptyset$.\\ 
Si $Pos$ et $Neg$ ne sont pas disjoints, alors les mots $u\in Pos\cap Neg$ devraient à la fois être acceptés et rejetés par l'ensemble gagnant.
\item La fermeture transitive (alternée) des contre-exemples d'implication de $Ex$ et $Uni$ ne contient pas de paire de mots $(u,v)$ telle que $u\in Pos \land v\in Neg$.\\
Si un telle paire existe, alors à nouveau, le mot $v$ devrait à la fois être accepté et rejeté par l'ensemble gagnant.

\end{enumerate}
\end{defi}
\noindent Ainsi, l'élève devra s'assurer que les AFD qu'il soumet à l'enseignant sont \emph{cohérents} avec l'échantillon $S$.
\begin{defi}
\label{consistency}
Soit $\mathcal{C}$ un $AFD$, $S=(Pos, Neg, Ex, Uni)$ un échantillon sans contradictions. On dit que $\mathcal{C}$ est \emph{cohérent} avec $S$ si
\begin{itemize}
\item $Pos\subseteq \mathcal{L}(\mathcal{C})$
\item $Neg\cap \mathcal{L}(\mathcal{C})=\emptyset$
\item $\forall (u,\mathcal{A})\in Ex, u\in\mathcal{L}(\mathcal{C})\implies  \mathcal{L}(\mathcal{C})\cap \mathcal{L}(\mathcal{A})\neq\emptyset$
\item $\forall (u,\mathcal{A})\in Uni, u\in\mathcal{L}(\mathcal{C})\implies  \mathcal{L}(\mathcal{A})\subseteq \mathcal{L}(\mathcal{C})$
\end{itemize}
\end{defi}
\noindent La section suivante va maintenant pouvoir décrire la manière dont l'élève peut conjecturer un $AFD$ cohérent avec un échantillon $S$.
\section{Résolution par la programmation logique}\label{prolog}
Afin de construire un $AFD$ cohérent avec un échantillon $S$ donné, une nouvelle étape de symbolisation va être nécessaire. Cette fois-ci, il s'agit de traduire le problème rationnel en une série de formules boléennes propositionnelles et de résoudre les problèmes de satisfaisabilité (\emph{problème SAT}) résultants. Il sera ensuite possible de traduire les \emph{modèles} (assignations de variables boléennes rendant la formule vraie) de ce problème SAT en ensemble gagnant pour le jeu de sûreté.

\begin{defi}{Elève pour les jeux de sureté rationnels\\}
\label{learner}
Soit $\mathfrak{G}_\Sigma=(A_\Sigma, I, F)$, un jeu de sûreté rationnel sur $\Sigma$, avec $A_\Sigma=(V_0,V_1,E)$ et $S=(Pos,Neg,Uni,Ex)$ un échantillon. Afin d'apprendre un AFD $\mathcal{C}$ à soumettre à l'enseignant, l'élève pour $\mathfrak{G}_\Sigma$ va créer une série de formules boléennes $\phi^S_n$ pour une valeur incrémentale de $n\in\mathbb{N}_0$ et telle que :
\begin{itemize}
\item La formule $\phi^S_n$ est satisfaisable si et seulement si il existe un AFD qui possède $n$ sommets et qui est cohérent avec $S$.
\item Un modèle $\mathfrak{M}$ de $\phi^S_n$ contient assez d'information pour construire un AFD $\mathcal{A}_\mathfrak{M}$ à $n$ sommets cohérent avec $S$.
\end{itemize}
\noindent Autrement formulé, l'objectif de $\phi^S_n$ est d'encoder un $AFD$ $\mathcal{A}=(Q,\Sigma,\delta,q_0,F)$ où $|Q|=n$ et cohérent avec $S$.\\
L'élève soumettra à l'enseignant un AFD $\mathcal{C}$ minimal, c.-à-d. construit à partir du modèle $\mathfrak{M}\models \phi_n^S$ pour la plus petite valeur de $n$ possible.
\end{defi}

\noindent La manière dont l'élève va construire cet AFD est la suivante. Etant donné $n$, on peut à l'avance fixer l'ensemble des états de cet $AFD$  à $Q=\{0,1,...$ $,n-1\}$ et le sommet de départ $q_0=0$. Ainsi, la formule $\phi^S_n$ n'a plus qu'à en encoder les transitions $\delta$ et les états finaux $F$ (pour rappel, $\Sigma$ est connu à l'avance par l'élève). Afin de représenter ces deux ensembles, nous allons introduire les variables boléennes $f_q$ et $d_{p,a,q}$ avec $a\in\Sigma$ et $p,q\in Q$. La variable $f_q=$ $vrai$ signifie que $q$ est un état final de $\mathcal{A}$ et $d_{p,a,q}=$ $vrai$ signifie que la transition $\delta(p,a)$ existe et transitionne vers $q$. De plus, vu que l'on cherche à encoder un AFD, et non un AFN, il faut imposer des conditions à nos variables, afin de respecter la définition \ref{deter}. Ces conditions s'obtiennent par la formule
\begin{equation}
\label{booldeter1}
\begin{aligned} \bigwedge _{p \in Q}~ \bigwedge _{a \in \varSigma }~ \bigwedge _{q, q' \in Q, q \ne q'}~ \neg (d_{p, a, q} \land d_{p, a, q'}) \end{aligned}
\end{equation}
qui assure qu'au plus un état $q$ peut être atteint depuis un état $p$ en lisant le mot $a$. A cela, nous allons ajouter la formule 
\begin{equation}
\label{booldeter2}
\begin{aligned} \bigwedge _{p \in Q}~ \bigwedge _{a \in \varSigma }~ \bigvee _{q \in Q}~ d_{p, a, q} \end{aligned}
\end{equation}
qui indique que la fonction de transition est totale, autrement dit que $\forall p\in Q, a\in\Sigma, \exists q\in Q, \delta(p,a)=q$. Bien que cela ne soit pas nécessaire pour encoder une fonction de transition déterministe, cela sera intéressant pour les formules que nous allons définir par la suite.

\noindent Ainsi, il est possible pour l'élève de construire un AFD $\mathcal{A}_\mathfrak{M}=(Q,\Sigma,q_0,\delta,F)$ à partir d'un modèle $\mathfrak{M}$ satisfaisant $\phi_n^{AFD}=(\ref{booldeter1})\land(\ref{booldeter2})$.
\begin{defi}
\label{translate}
Soit $\mathfrak{M}$ un modèle satisfaisant $\phi_n=(\ref{booldeter1})\land(\ref{booldeter2})$, alors on peut construire un AFD $\mathcal{A}_\mathfrak{M}=(Q,\Sigma,\delta,q_0,F)$ avec $Q$, $q_0$ et $\Sigma$ fixés, $\delta(p,a)=q$ pour tout $\mathfrak{M}(d_{p,a,q})=$ vrai, et $F=\{q\in Q$ $|$ $\mathfrak{M}(f_q)=$ vrai $\}$\\
Où $\mathfrak{M}(x)$ correspond à la valeur de x dans le modèle $\mathfrak{M}$.
\end{defi}
Il reste maintenant à rendre cet AFD cohérent avec $S$. Pour cela, il est nécessaire que $\mathcal{A}_\mathfrak{M}$ accepte ou rejette tous les mots de $S$, définis par l'ensemble $W=Pos\cup Neg\cup Ante(Ex)$ $\cup$ $Ante(Uni)$ (où, pour un contre-exemple d'implication $i=(u,\mathcal{A})$, on a $Ante(i)=u$). Autrement dit, il faut qu'il existe un parcours dans $\mathcal{A}_\mathfrak{M}$ pour chaque préfixe des mots de $W$. Nous allons donc introduire une nouvelle variable boléenne $x_{u,q}$ pour laquelle $x_{u,q}=$ $vrai$ signifie que $\mathcal{A}_\mathfrak{M}$ atteint l'état $q\in Q$ en lisant le mot $u$ et utiliser cette variable pour décrire le parcours de $\mathcal{A}_\mathfrak{M}$ par les mots de l'ensemble $Pref(W)$.\\

\noindent Nous commencons par introduire la formule
\begin{equation}
\label{boolW1}
\begin{aligned} x_{\varepsilon , q_0} \end{aligned}
\end{equation}
laquelle indique que n'importe quel parcours de $\mathcal{A}_\mathfrak{M}$ commence par l'état $q_0$.\\ 
Ensuite, la formule
\begin{equation}
\label{boolW2}
\begin{aligned} \bigwedge _{u \in Pref (W)}~ \bigwedge _{q \ne q' \in Q}~ \neg (x_{u, q} \land x_{u,q'}) \end{aligned}
\end{equation}
assure que pour chaque mot $u$ de l'ensemble des préfixes des mots de l'échantillon $S$, il existe au plus un état $q$ tel que $x_{u,q}=$ $vrai$. D'ailleurs, cet état $q$ est garanti d'exister par la formule \ref{booldeter2} introduite précédemment.

\noindent Pour finir, la formule
\begin{equation}
\label{boolW3}
\begin{aligned} \bigwedge _{ua \in Pref (W)}~ \bigwedge _{p,q \in Q}~ (x_{u, p} \wedge d_{p, a, q}) \rightarrow x_{ua, q} \end{aligned}
\end{equation}
décrit la manière dont un parcours de l'automate $\mathcal{A}_\mathfrak{M}$ par un mot $ua\in Pref(W)$ fonctionne. Si un état $p$ est atteint en lisant le mot $u$, et qu'une transition $\delta(p,a)=q$ existe (la variable $d_{p,a,q}=$ $vrai$) alors l'état $q$ sera atteint en lisant le mot $ua$ et donc $x_{ua,q}=$ $vrai$.\\

\noindent La conjonction de ces trois formules $\phi^W_n=(\ref{boolW1})\land(\ref{boolW2})\land(\ref{boolW3})$ nous permet ainsi de produire un AFD $\mathcal{A}_\mathfrak{M}$ qui permettra d'accepter ou de rejetter (i.e. d'être parcouru par) tous les mots de $W$.\\

\noindent Pour rendre un AFD $\mathcal{A}_\mathfrak{M}$ construit à partir d'un modèle $\mathfrak{M}$ de $\phi_n=\phi_n^{AFD}\land\phi^W_n$ cohérent avec $S$, il reste maintenant à définir des formules boléennes $\phi_n^{Pos}$, $\phi_n^{Neg}$, $\phi_n^{Ex}$ et $\phi_n^{Uni}$ qui assureront le respect des conditions de la définition \ref{consistency}.\\

\noindent Premièrement, la formule suivante pour $\phi_n^{Pos}$ 
\begin{equation}
\label{boolPos}
\begin{aligned} \bigwedge_{u\in Pos} \bigwedge_{q\in Q} x_{u,q} \rightarrow f_q \end{aligned}
\end{equation} 
permet de s'assurer que les mots de $Pos$ sont acceptés par $\mathcal{A}_\mathfrak{M}$. En effet, si $x_{u,q}=$ $vrai$, alors $q$ est l'état atteint lors de la lecture du mot $u$ par $\mathcal{A}_\mathfrak{M}$. Par cette formule, une valeur $x_{u,q}=$ $vrai$ impliquera $f_q=$ $vrai$ et donc $q$ sera un état final, ce qui permettra d'accepter $u$. Nous avons donc bien que si $\mathfrak{M}\models \phi_n^{Pos}\land\phi_n^W\land\phi_n^{AFD}$, alors $Pos\subseteq \mathcal{L}(\mathcal{A}_\mathfrak{M})$\\

\noindent A l'inverse, la formule suivante pour $\phi_n^{Neg}$ 
\begin{equation}
\label{boolNeg}
\begin{aligned} \bigwedge_{u\in Neg} \bigwedge_{q\in Q} x_{u,q} \rightarrow \neg f_q \end{aligned}
\end{equation} 
assurera, par un raisonnement similaire, que les mots de $Neg$ seront rejetés par $\mathcal{A}_\mathfrak{M}$, et donc que si $\mathfrak{M}\models \phi_n^{Neg}\land\phi_n^W\land\phi_n^{AFD}$, alors $\mathcal{L}(\mathcal{A}_\mathfrak{M})\cap Neg=\emptyset$.\\

\noindent Ensuite, afin que la formule pour $\phi_n^{Uni}$ assure que pour tout contre-exemple d'implication universelle $i_{Uni}=(u,\mathcal{A}) \in Uni$, avec $\mathcal{A}=(Q^\mathcal{A},\Sigma,q_0^\mathcal{A},\delta^\mathcal{A},F^\mathcal{A})$, si $\mathcal{A}_\mathfrak{M}$ accepte $u$, alors il doit aussi accepter tous les $v\in\mathcal{L}(\mathcal{A})$, nous allons définir des variables boléennes $y_{q,q^\mathcal{A}}$ telles que $y_{q,q^\mathcal{A}}=$ $vrai$ indique qu'il existe un mot $v\in\Sigma^*$ pour lequel un parcours de $\mathcal{A}_\mathfrak{M}$ par $v$ se termine sur l'état $q\in Q$ et un parcours de $\mathcal{A}$ par ce même $v$ se termine sur l'état $q^\mathcal{A}\in Q^\mathcal{A}$. Autrement formulé, ces variables vont nous aider à déterminer les paires d'états atteintes par un parcours en parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ par $v$. 

\noindent Soit $i_{Uni}=(u,\mathcal{A}) \in Uni$, un contre-exemple d'implication universelle, avec $\mathcal{A}=(Q^\mathcal{A},\Sigma,q_0^\mathcal{A},\delta^\mathcal{A},F^\mathcal{A})$, cette définition est donnée par
\begin{equation}
\label{booluni1}
y_{q_0,q_0^\mathcal{A}}
\end{equation}
qui indique que tout parcours en parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ commence sur la paire d'état $(q_0,q_0^\mathcal{A})$, et 
\begin{equation}
\label{booluni2}
\begin{aligned}
\bigwedge_{p,q\in Q}~ \bigwedge_{(p^\mathcal{A},a,q^\mathcal{A})\in\delta^\mathcal{A}}~ (y_{p,p^\mathcal{A}}\land d_{p,a,q})\rightarrow y_{q,q^\mathcal{A}}
\end{aligned}
\end{equation}
qui, de manière analogue à la formule \ref{boolW3}, indique que si une paire d'états $(p,p^\mathcal{A})\in Q\times Q^\mathcal{A}$ est atteinte par le parcours en parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ par un mot de $\Sigma^*$, alors pour toutes transitions $\delta^\mathcal{A}(p^\mathcal{A},a)=q^\mathcal{A}$, s'il y a une transition $\delta(p,a)=q$ dans $\mathcal{A}_\mathfrak{M}$ (ce qui est toujours le cas par \ref{booldeter2} pour $a\in\Sigma\setminus\epsilon$), alors on peut transitionner via $a$ vers la paire d'états $(q,q^\mathcal{A})\in Q\times Q^\mathcal{A}$ et donc $y_{q,q^\mathcal{A}}=$ $vrai$.\\

\noindent Grâce à cette définition de $y_{q,q^\mathcal{A}}$, on peut assurer, par la formule 
\begin{equation}
\label{booluni3}
\begin{aligned} \bigl ( \bigvee _{q \in Q}~ x_{u, q} \wedge f_q \bigr ) \rightarrow \bigl ( \bigwedge _{q \in Q}~ \bigwedge _{q^\mathcal{A} \in F^\mathcal A}~ y_{q, q^\mathcal{A}} \rightarrow f_q \bigr ) \end{aligned}
\end{equation}
que si un état final est atteint dans $\mathcal{A}_\mathfrak{M}$ en lisant le mot $u$, alors le parcours de $\mathcal{A}_\mathfrak{M}$ pour chaque mot de $\mathcal{L}(\mathcal{A})$ mène aussi à un état final de $\mathcal{A}_\mathfrak{M}$.\\

\noindent En construisant une formule $\phi_{n,i}^{Uni}=(\ref{booluni1})\land(\ref{booluni2})\land(\ref{booluni3})$ pour chaque contre-exemple d'implication universelle $i\in Uni$, on obtient la définition de la formule $\phi_n^{Uni}=\bigwedge_{i\in (Uni)}\phi^{Uni}_{n,i}$.

\noindent Par la construction que l'on vient de décrire, on a bien que si $\mathfrak{M}\models \phi_n^{Uni}\land\phi_n^W\land\phi_n^{AFD}$, alors $\forall (u,\mathcal{A})\in Uni, u\in\mathcal{L}(\mathcal{\mathcal{A}_\mathfrak{M}})\implies  \mathcal{L}(\mathcal{A})\subseteq \mathcal{L}(\mathcal{\mathcal{A}_\mathfrak{M}})$\\

\noindent Cependant, il est important de noter que les variables $y_{q,q^\mathcal{A}}$ ne décrivent pas exactement le parcours en parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ par les mots de $\mathcal{L}(\mathcal{A})$. En effet, étant donné que $\mathcal{A}$ est non-déterministe, une transition $\delta^\mathcal{A}(p^\mathcal{A},\epsilon)=q^\mathcal{A}$ pourrait exister, ce qui rendrait la prémisse de la formule \ref{booluni2} fausse car $\mathcal{A}_\mathfrak{M}$ est déterministe et donc ne possède pas de transitions pour $\epsilon$. L'implication aura donc pour conséquence $y_{q,q^\mathcal{A}}=$ $vrai$ sans qu'un mot $v$ existe tel que le parcours en parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ par $v$ se termine sur la paire d'états $(q,q^\mathcal{A})\in Q\times Q^\mathcal{A}$.\\
La formule $\phi_n^{Uni}$ reste cependant correcte. En effet, dans l'objectif d'accepter tous les mots $v\in\mathcal{L}(\mathcal{A})$, il n'est pas nécessaire de savoir s'ils existent. Par contre, afin que la formule $\phi_n^{Ex}$ que nous allons construire par la suite assure bien que, pour un contre-exemple d'implication existentielle $i_{Ex}=(u,\mathcal{A})\in Ex$, si $u\in\mathcal{L}(\mathcal{A}_\mathfrak{M})$, alors il existe au moins un $v\in\mathcal{L}(\mathcal{A})$ tel que $v\in\mathcal{L}(\mathcal{A}_\mathfrak{M})$, il n'est plus suffisant de se baser sur les variables $y_{q,q^\mathcal{A}}$ car elle n'assurent pas l'existence d'un tel mot. Nous allons devoir procéder de manière plus robuste.\\

\noindent Soit $i_{Ex}=(u,\mathcal{A})\in Ex$ un contre-exemple d'implication existentielle, avec $\mathcal{A}=(Q^\mathcal{A},\Sigma,q_0^\mathcal{A},\delta^\mathcal{A},F^\mathcal{A})$, nous allons maintenant introduire une dernière variable boléenne $z_{q,q^\mathcal{A},\mathnormal{l}}$ avec $q\in Q$, $q^\mathcal{A}\in Q^\mathcal{A}$ et $\mathnormal{l}\in \{0,...$ $,k\}$, $k\in\mathbb{N}$ pour laquelle $z_{q,q^\mathcal{A},\mathnormal{l}}=$ $vrai$ indique qu'il existe un mot $v\in\Sigma^*$ de longueur $|v|=\mathnormal{l}$ tel que le parcours en parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ par $v$ se termine sur la paire d'états $(q,q^\mathcal{A})\in Q\times Q^\mathcal{A}$.\\

\noindent Afin que le nombre de variable nécessaire soit fini, il faut déterminer une valeur maximale pour $\mathnormal{l}$. Il faut donc trouver la plus petite longueur maximale de mot de $\Sigma^*$ pour laquelle $z_{q,q^\mathcal{A},\mathnormal{l}}$ permet de décrire tous les parcours en  parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$. Nous allons déterminer cette valeur sur base d'une simple observation : si, lors du parcours en parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ par un mot $v\in\Sigma$ un état $(q,q^\mathcal{A})\in Q\times Q^\mathcal{A}$ est atteint deux fois, alors le facteur $w\in\Sigma^*$ de $v$ entre cette répétition peut être retiré de $v$ sans que $z_{q,q^\mathcal{A},\mathnormal{l}}$ ne perde d'information. Ainsi, la valeur maximale pour $\mathnormal{l}$ est la longueur maximale de mot telle que, lors du parcours en parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ par ce mot, chaque paire d'état $(q,q^\mathcal{A})\in Q\times Q^\mathcal{A}$ est atteinte au plus une fois. Cette valeur sera donc donnée par $k=|Q||Q^\mathcal{A}|-1=n|Q^\mathcal{A}|-1$\\

Maintenant que nous avons réussi à limiter le nombre de ces variables, passons à leur définition.\\
Pour commencer, la formule  
\begin{equation}
\label{boolex1}
\begin{aligned}
z_{q_0,q_0^\mathcal{A},0}
\end{aligned}
\end{equation}
permet d'indiquer, de manière similaire aux formules \ref{boolW1} et \ref{booluni1}, qu'un parcours en parallèle $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ commencera sur la paire d'états $(q_0,q_0^\mathcal{A})\in Q\times Q^\mathcal{A}$.\\
Ajouté à cela, la formule 
\begin{equation}
\label{boolex2}
\begin{aligned}
\bigwedge_{(q,q^\mathcal{A})\in Q\times Q^\mathcal{A}\setminus \{(q_0,q_0^\mathcal{A})\}}~ \neg z_{q,q^\mathcal{A},0}
\end{aligned}
\end{equation}
assure que toutes les autres variables $z_{q,q^\mathcal{A},0}=$ $faux$ car le seul parcours valide par le mot $\epsilon$ (i.e. par un mot de longueur $0$) selon le sens que l'on veut donner à notre variable $z_{q,q^\mathcal{A},\mathnormal{l}}$ est celui qui amène à la paire d'états initiaux comme décrit par \ref{boolex1}.\\
Ensuite, la formule
\begin{equation}
\label{boolex3}
\begin{aligned}
\bigwedge_{p,q\in Q}~ \bigwedge_{(p^\mathcal{A},a,q^\mathcal{A})\in\delta^\mathcal{A}}~ \bigwedge_{\mathnormal{l}\in\{0,... ,k-1\}}~ (z_{p,p^\mathcal{A}, \mathnormal{l}}\land d_{p,a,q})\rightarrow z_{q,q^\mathcal{A},\mathnormal{l}+1}
\end{aligned}
\end{equation}
décrit, de manière analogue à \ref{boolW2} et \ref{booluni2}, que si la paire d'états $(p,p^\mathcal{A})\in Q\times Q^\mathcal{A}$ est atteinte lors du parcours en parallèle de $\mathcal{A}_\mathfrak{M}$ et $\mathcal{A}$ par un mot de longueur $\mathnormal{l}$, et qu'il existe les transitions $\delta (p,a)=q$ et $\delta^\mathcal{A}(p^\mathcal{A},a)=q^\mathcal{A}$ avec $q\in Q$ et $q^\mathcal{A}\in Q^\mathcal{A}$, alors on atteint la paire d'états $(q,q^\mathcal{A})$ par le parcours d'un mot de longueur $\mathnormal{l}+1$ et donc $z_{q,q^\mathcal{A},\mathnormal{l}+1}=$ $vrai$.\\
Pour finir, afin d'assurer l'existence de ce mot de longueur $\mathnormal{l}+1$, la formule 
\begin{equation}
\label{boolex4}
\begin{aligned}
\bigl ( \bigwedge_{q\in Q}~ \bigwedge_{q^\mathcal{A}\in Q^\mathcal{A}}~ \bigwedge_{\mathnormal{l}\in\{0,... ,k-1\}}~ z_{q,q^\mathcal{A},\mathnormal{l}+1} \bigr ) \rightarrow \bigr ( \bigvee_{p\in Q}~ \bigvee_{(p^\mathcal{A},a,q^\mathcal{A})\in\delta^\mathcal{A}}~ d_{p,a,q}\land z_{p,p^\mathcal{A},\mathnormal{l}} \bigr )
\end{aligned}
\end{equation}
empêche $z_{q,q^\mathcal{A},\mathnormal{l}+1}=$ $vrai$ s'il n'y a pas de paire d'états $(p,p^\mathcal{A})$ atteinte par un mot de longueur $\mathnormal{l}$ tel que $z_{p,p^\mathcal{A},\mathnormal{l}}=$ $vrai$. Cela empêche la formule \ref{boolex3} de rendre $z_{q,q^\mathcal{A},\mathnormal{l}+1}=$ $vrai$ s'il est atteint par une transition $\delta^\mathcal{A}(p^\mathcal{A},\epsilon,q^\mathcal{A})$ car la longueur du mot lu n'aura pas été incrémentée.\\

\noindent Grâce à cette définition de $z_{q,q^\mathcal{A},\mathnormal{l}}$, on peut assurer, par la formule
\begin{equation}
\label{boolex5}
\begin{aligned}
\bigl ( \bigvee_{q\in Q}~ x_{u,q}\land f_q \bigr ) \rightarrow \bigl ( \bigvee_{q\in Q}~ \bigvee_{q^\mathcal{A}\in Q^\mathcal{A}}~ \bigvee_{\mathnormal{l}\in\{0,...,k\}}~ z_{q,q^\mathcal{A},\mathnormal{l}}\land f_q \bigr )
\end{aligned}
\end{equation}
que, si un mot $u$ est accepté par $\mathcal{A}_\mathfrak{M}$, alors au moins un des mots $v\in\mathcal{L}(\mathcal{A})$ menant à un état final dans $\mathcal{A}$, mènera à un état final dans $\mathcal{A}_\mathfrak{M}$ et sera donc accepté par ce dernier.\\

\noindent En construisant une formule $\phi_{n,i}^{Ex}=(\ref{boolex1})\land(\ref{boolex2})\land(\ref{boolex3})\land(\ref{boolex4})\land(\ref{boolex5})$ pour chaque contre-exemple d'implication existentielle $i\in Ex$, on obtient la définition de la formule $\phi^{Ex}_n=\bigwedge_{i\in(Ex)}\phi_{n,i}^{Ex}$.\\
Par la construction de cette formule, on a bien que si $\mathfrak{M}\models\phi_n^{Ex}\land\phi^{W}_n\land\phi^{AFD}_n$, alors $\forall(u,\mathcal{A})\in Ex, u\in\mathcal{L}(\mathcal{A})\implies \mathcal{L}(\mathcal{A}_\mathfrak{M})\cap\mathcal{L}(\mathcal{A})\neq\emptyset$\\

Ainsi, nous obtenons une formule $\phi^S_n=\phi_n^{AFD}\land\phi_n^{W}\land\phi_n^{Pos}\land\phi_n^{Neg}\land\phi_n^{Ex}\land\phi_n^{Uni}$ dont un modèle $\mathfrak{M}$ contiendra assez d'information pour construire un $AFD$ $\mathcal{A}_\mathfrak{M}$ à $n$ états et cohérent avec l'échantillon $S$.\\

Tous les outils nécessaires à l'apprentissage étant maintenant définis, la section suivante va détailler l'échange entre l'enseignant et l'élève menant à la construction de l'ensemble gagnant d'un problème de sûreté.
\newpage
\section{Algorithmes}
Nous allons maintenant décrire les algorithmes qui vont permettre l'apprentissage d'un ensemble gagnant pour les jeux de sûreté. 
Cette description débutera par des algorithmes généraux, peu détaillés, lesquels seront au fur et à mesure décomposés afin d'être expliqué plus en profondeur.\\
Soit un jeu de sûreté rationel $\mathfrak{G}_\Sigma=(A_\Sigma, \mathcal{A}_I, \mathcal{A}_F)$ sur $\Sigma$, avec $A_\Sigma=(\mathcal{A}_{V_0}, \mathcal{A}_{V_1}, \mathcal{T}_E)$ que nous allons fixer pour le reste de cette section, l'algorithme \ref{alginifnitemain} décrit, de manière générale, l'échange entre l'élève et l'enseignant pour $\mathfrak{G}_\Sigma$.
\begin{algorithm}[H]
\caption{Apprentissage}\label{alginifnitemain}
\hspace*{\algorithmicindent} 
\begin{tabular}{lll}
	\textbf{Entrées} & \textbf{$\mathfrak{G}_\Sigma$} : &Un jeu de sûreté rationel sur $\Sigma$\\
	&\textbf{teacher} : &Un enseignant pour $\mathfrak{G}_\Sigma$\\
	&\textbf{learner} : &Un élève pour $\mathfrak{G}_\Sigma$\\
	\textbf{Sortie} &\multicolumn{2}{l}{Un AFD décrivant $W_0$ l'ensemble gagnant de $\mathfrak{G}_\Sigma$ pour le joueur $j_0$}\\
\end{tabular}\\
\begin{algorithmic}[1]
\State $S\gets(\emptyset,\emptyset,\emptyset,\emptyset)$\Comment Echantillon
\Repeat
	\State $\mathcal{A}_S \gets learner.conjecture(S)$\Comment \ref{learner}
	\State $counterexample\gets teacher.check(\mathfrak{G}_\Sigma, \mathcal{A}_S)$\Comment\ref{teacher}
	\If{$counterexample\neq \emptyset$}
		\State Ajouter $counterexample$ dans $S$
	\EndIf
		
\Until{$counterexample=\emptyset$}\\
\Return $\mathcal{A}_S$
\end{algorithmic}
\end{algorithm}

\noindent Avant de démarrer l'apprentissage, on initialise l'échantillon $S=(Pos,Neg,Uni,Ex)$ vide. C'est ensuite dans la boucle principale de l'algorithme que se déroulera toute l'étape d'apprentissage. Il s'agit donc de la boucle de type $CEGIS$ décrite dans la section \ref{sectionapprentissage}. Chaque itération de cette boucle commence par l'élève conjecturant un AFD $\mathcal{A}_S$ cohérent avec $S$. La méthode $learner.conjecture$ est décrite par l'algorithme \ref{alginfiniteconjecture}.

\begin{algorithm}[H]
\caption{learner.conjecture}\label{alginfiniteconjecture}
\hspace*{\algorithmicindent} 
\begin{tabular}{lll}
	\textbf{Entrées} & \textbf{S} : &L'échantillon (sans contradictions) actuel pour l'apprentissage.\\
	\textbf{Sortie} &\multicolumn{2}{l}{Un AFD minimal cohérent avec $S$.}\\
\end{tabular}\\
\begin{algorithmic}[1]
\State $n\gets 0$
\Repeat
	\State $n\gets n+1$
	\State $\phi_n^S\gets learner.constructSAT(S,n)$
	\State $\mathfrak{M} \gets learner.solveSAT(\phi_n^S)$\Comment $\mathfrak{M}$ n'existe peut-être pas
\Until{$\mathfrak{M}\models \phi_n^S$}
\State $\mathcal{A}_\mathfrak{M}\gets learner.translatemodel(\mathfrak{M},n)$
\State\Return $\mathcal{A}_\mathfrak{M}$
\end{algorithmic}
\end{algorithm}
Afin de conjecturer un AFD minimal cohérent avec $S$ (On expliquera un peu plus tard pourquoi $S$ est toujours sans contradictions), l'élève va, par la méthode $learner.constructSAT$, construire un problème SAT correspondant à la formule $\phi_n^S$ décrite à la section \ref{prolog} pour une valeur de $n$ démarrant à $n=1$ (Elle est initialisée à $0$ mais est immédiatement incrémentée dans la boucle) pour ensuite essayer de résoudre ce problème à l'aide de la méthode $learner.solveSAT$. En pratique, cette méthode va correspondre à l'utilisation d'un \emph{solveur SAT}, un outil servant à résoudre les problèmes SAT. Si aucun modèle n'est retourné par le solveur SAT pour la valeur actuelle de $n$, on passe à l'itération suivante avec une valeur de $n$ incrémentée.\\
Dès qu'un modèle $\mathfrak{M}$ est trouvé, on sort de la boucle.\\
La fonction $learner.translatemodel$ va construire l'AFD minimal $\mathcal{A}_\mathfrak{M}$ qui sera la valeur de retour.

\begin{algorithm}[H]
\caption{leaner.constructSAT}\label{alginfiniteconstructsat}
\hspace*{\algorithmicindent} 
\begin{tabular}{lll}
	\textbf{Entrées} & \textbf{S} : &L'échantillon actuel pour l'apprentissage.\\
	&\textbf{n} : &La taille (nombre d'états de l'AFD correspondant) du\\
	&&problème SAT à construire.\\
	\textbf{Sortie} &\multicolumn{2}{l}{Le problème SAT correspondant à $\phi_n^S$.}\\
\end{tabular}\\
\begin{algorithmic}[1]
\State 
\end{algorithmic}
\end{algorithm}


La manière dont l'enseignant effectue les vérifications de la définition \ref{teacher} par la méthode $teacher.check$ est décrite par l'algorithme \ref{alginfinitecheck}
\begin{algorithm}[H]
\caption{teacher.check}\label{alginfinitecheck}
\hspace*{\algorithmicindent} 
\begin{tabular}{lll}
	\textbf{Entrées} & \textbf{$\mathfrak{G}_\Sigma$} : &Un jeu de sûreté rationel sur $\Sigma$\\
	&\textbf{$\mathcal{C}$} : &AFD tentant de décrire l'ensemble gagnant $W_0$ pour\\
	&&le joueur $j_0$ de $\mathfrak{G}_\Sigma$.\\
	\textbf{Sortie} &\multicolumn{2}{l}{Un contre-exemple si l'une des règles de la définition d'ensemble}\\
	&\multicolumn{2}{l}{gagnant (\ref{infinitewinningset}) n'est pas respectée.}
\end{tabular}\\
\begin{algorithmic}[1]
\State $\mathcal{B}_I\gets\mathcal{A}_I\setminus\mathcal{C}$\Comment Vérification 1 : sommets initiaux 
\If{$\mathcal{L}(\mathcal{B}_I)\neq\emptyset$}
	\State $u\gets anyword(\mathcal{B}_I)$
	\State\Return $u$
\EndIf
\State $\mathcal{B}_F\gets\mathcal{C}\setminus\mathcal{A}_F$\Comment Vérification 2 : sommets sûrs
\If{$\mathcal{L}(\mathcal{B}_F)\neq\emptyset$}
	\State $u\gets anyword(\mathcal{B}_F)$
	\State\Return $u$
\EndIf
\State $\mathcal{B}_{E1}\gets\mathcal{R}(\mathcal{T}_E)^{-1}(\mathcal{C})$\Comment Vérification 3 : fermeture existentielle
\State $\mathcal{B}_{E2}\gets\mathcal{A}_{V_0}\setminus\mathcal{B}_{E1}$
\State $\mathcal{B}_E\gets\mathcal{B}_{E2}\cap\mathcal{C}$
\If{$\mathcal{L}(\mathcal{B}_E)\neq\emptyset$}
	\State $u\gets anyword(\mathcal{B}_E)$
	\State $\mathcal{A}\gets\mathcal{R}(\mathcal{T}_E)(\{u\})$
	\State\Return $(u,\mathcal{A})$ 
\EndIf
\State $\mathcal{B}_{U1}\gets(\mathcal{A}_{V_0}\cup\mathcal{A}_{V_1})\setminus\mathcal{C}$\Comment Vérification 4 : fermeture universelle
\State $\mathcal{B}_{U2}\gets\mathcal{R}(\mathcal{T}_E))^{-1}(\mathcal{B}_{U1})$
\State $\mathcal{B}_U\gets\mathcal{A}_{V_1}\cap\mathcal{C}\cap\mathcal{B}_{U2}$
\If{$\mathcal{L}(\mathcal{B}_U)\neq\emptyset$}
	\State $u\gets anyword(\mathcal{B}_U)$
	\State $\mathcal{A}\gets\mathcal{R}(\mathcal{T}_E)(\{u\})$
	\State\Return $(u,\mathcal{A})$ 
\EndIf
\end{algorithmic}
\end{algorithm}
\noindent La méthode $anyword(\mathcal{A})$ retourne un mot au hasard de $\mathcal{A}$.\\

Afin de vérifier que $\mathcal{C}$ est un ensemble gagnant pour le jeu $\mathfrak{G}_\Sigma$, l'enseignant va construire divers AFN lesquels vont permettre de vérifier individuellement les 4 règles de la définition \ref{infinitewinningset}.\\

Pour les sommets initiaux, l'enseignant calcule un AFN $\mathcal{B}_I$ tel que $\mathcal{L}(\mathcal{B}_I)=\mathcal{L}(\mathcal{A}_I)\setminus\mathcal{L}(\mathcal{C})$. Si $\mathcal{L}(\mathcal{B}_I)\neq\emptyset$, cela signifie qu'il y a au moins un sommet initial qui ne fait pas partie de l'ensemble gagnant. Dans ce cas, l'enseignant construit un contre-exemple positif en prenant n'importe quel mot de $\mathcal{L}(\mathcal{B}_I)$ et le retourne.\\
Pour les sommets sûrs, l'enseignant calcule l'AFN $\mathcal{B}_F$ tel que $\mathcal{L}(\mathcal{B}_F)=\mathcal{L}(\mathcal{C})\setminus\mathcal{L}(\mathcal{A}_F)$. Si $\mathcal{L}(\mathcal{B}_F)\neq\emptyset$, alors c'est qu'au moins un sommet de $W_0$ n'est pas inclu dans $F$. Dans ce cas, l'enseignant construit un contre-exemple négatif en prenant n'importe quel mot de $\mathcal{L}(\mathcal{B}_F)$ et le retourne.\\
En ce qui concerne la fermeture existentielle, plusieurs AFN sont nécessaires. Premièrement, l'enseignant calcule l'AFN $\mathcal{B}_{E1}$ qui est l'image de $\mathcal{C}$ par la relation inverse $\mathcal{R}(\mathcal{T}_E)^{-1}$. Ainsi, $\mathcal{L}(\mathcal{B}_{E1})$ contient tous les sommets qui ont un successeur dans $\mathcal{L}(\mathcal{C})$. Ensuite, $\mathcal{B}_{E2}$ est construit de manière que $\mathcal{L}(\mathcal{B}_{E2})=\mathcal{L}(\mathcal{A}_{V_0})\setminus\mathcal{L}(\mathcal{B}_{E1})$. On aura donc que $\mathcal{B}_{E2}$ contient tous les sommets appartenant à $j_0$ qui n'ont pas de successeur dans $\mathcal{C}$. Pour finir, afin d'obtenir tous les sommets de $j_0$ qui sont dans $\mathcal{C}$ mais qui n'ont eux-mêmes pas de successeurs dans $\mathcal{C}$, l'enseignant construit l'AFN $\mathcal{B}_E$ tel que $\mathcal{L}(\mathcal{B}_E)=\mathcal{L}(\mathcal{C})\cap\mathcal{L}(\mathcal{B}_{E2})$. Si $\mathcal{L}(\mathcal{B}_E)\neq\emptyset$, alors il existe un sommet de $j_0$ qui contredit la fermeture existentielle. L'enseignant construit un contre-exemple d'implication existentielle en prenant un mot $u\in\mathcal{L}(\mathcal{B}_E)$ et en calculant $\mathcal{A}=\mathcal{R}(\mathcal{T}_E)(\{u\})$, l'image de ce mot par la relation $\mathcal{R}(\mathcal{T}_E)$. Il retourne ainsi $(u,\mathcal{A})$ signifiant qu'un sommet $u$ appartenant à $j_0$ est inclu dans l'ensemble gagnant sans qu'au moins un de ses successeurs (les mots de $\mathcal{L}(\mathcal{A})$) n'ait été accepté.\\
La fermeture universelle nécessite aussi trois étapes. L'enseignant commence par calculer l'automate $\mathcal{B}_{U1}=(\mathcal{A}_{V_0}\cup\mathcal{A}_{V_1})\setminus\mathcal{C}$, l'AFN qui décrit tous les sommets de $\mathfrak{G}_\Sigma$ qui ne sont pas dans $\mathcal{C}$. Ensuite, en prenant l'image de $\mathcal{B}_{U1}$ par la relation inverse $\mathcal{R}(\mathcal{T}_E)^{-1}$, l'enseignant obtient $\mathcal{B}_{U2}$ qui décrit tous les sommets ayant au moins un successeur qui n'appartient pas à $\mathcal{C}$. Enfin, l'intersection de $\mathcal{B}_{U2}$ et de $\mathcal{C}$ permet d'obtenir tous les sommets de $\mathcal{C}$ qui ont au moins un successeur hors de $\mathcal{C}$. En ajoutant l'intersection avec $\mathcal{A}_{V_1}$, on obtient l'AFN $\mathcal{B}_U$ qui décrit tous les sommets du joueur $j_1$ qui ont un successeur hors de $\mathcal{C}$. Si $\mathcal{L}(\mathcal{B}_U)\neq\emptyset$, chaque mot $u\in\mathcal{L}(\mathcal{B}_U)$ contredit la fermeture universelle. L'enseignant construit et retourne donc un contre-exemple d'implication universelle $(u,\mathcal{A})$ en prenant un de ces mots $u$ et $\mathcal{A}$ son image par la relation $\mathcal{R}(\mathcal{T}_E)$.Ce contre-exemple signifie qu'un sommet $u$ appartenant à $j_1$ est inclu dans l'ensemble gagnant sans que tous ses successeurs y soient inclus.\\

\noindent Si aucun contre-exemple n'a été retourné, alors $\mathcal{C}$ décrit $W_0$.

\begin{algorithm}[H]
\caption{teacher.translate}\label{alginfinitetranslate}
\hspace*{\algorithmicindent} 
\begin{tabular}{lll}
	\textbf{Entrées} & \textbf{$\mathfrak{M}$} : &Un modèle contenant assez d'information\\
	&&pour construire un AFD\\
	&\textbf{n} :&Le nombre d'états dans l'AFD à construire.\\
	\textbf{Sortie} &\multicolumn{2}{l}{Un AFD à $n$ états correspondant à $\mathfrak{M}$}\\
\end{tabular}\\
\begin{algorithmic}[1]
\State $Q\gets[]$
\For{$i$ allant de $0$ à $n-1$}
	\State initialiser le sommet $q_i$
	\State ajouter $q_i$ dans $Q$
\EndFor
\State $q_0\gets Q[0]$
\State $\delta\gets[]$
\For{chaque variable $d_{p,a,q}$ dans $\mathfrak{M}$}
	\If{$\mathfrak{M}(d_{p,a,q})=$ $vrai$}
		\State ajouter $(Q[p],a,Q[q])$ dans $\delta$
	\EndIf
\EndFor
\State $F\gets[]$
\For{chaque variable $f_q$ dans $\mathfrak{M}$}
	\If{$\mathfrak{M}(f_q)=$ $vrai$}
		\State ajouter $Q[q]$ dans $F$
	\EndIf
\EndFor
\State $\mathcal{A}\gets(Q,\Sigma,q_0,\delta,F)$
\State\Return $\mathcal{A}$
\end{algorithmic}
\end{algorithm}



\newpage
\subsection{Complexité}
\newpage 
\subsection{Exemple}

\begin{algorithm}[H]
\caption{}\label{}
\hspace*{\algorithmicindent} 
\begin{tabular}{lll}
	\textbf{Entrées} & \textbf{} : &\\
	&\textbf{} : &\\
	\textbf{Sortie} &\multicolumn{2}{l}{}\\
\end{tabular}\\
\begin{algorithmic}[1]
\State 
\end{algorithmic}
\end{algorithm}

\newpage
\noindent Pourquoi a-t'on besoin de $y_{q,q^\mathcal{A}}$ et $z_{q,q^\mathcal{A},\mathnormal{l}}$ si\\


\noindent Soit $(u,\mathcal{A})$ contre-exemple universel et $n$ nombre d'état de l'AFD à conjecturer. \textbf{Si $\mathcal{L}(\mathcal{A})$ est fini}, en supposant qu'on a construit $x_u,q$ pour les mots de $Pref(\mathcal{L}(\mathcal{A}))$ en plus de $Pref(W)$.
\begin{equation}
\begin{aligned}
\bigl ( \bigvee_{p\in Q}~ x_{u,p}\land f_p \bigr ) \implies \bigl ( \bigwedge_{v\in\mathcal{L}(\mathcal{A}), |v|<=n|Q^\mathcal{A}|}~ x_{v,q}\implies f_q \bigr )
\end{aligned}
\end{equation}

\noindent Soit $(u,\mathcal{A})$ contre-exemple existentiel et $n$ nombre d'état de l'AFD à conjecturer. \textbf{Si $\mathcal{L}(\mathcal{A})$ est fini}, en supposant qu'on a construit $x_u,q$ pour les mots de $Pref(\mathcal{L}(\mathcal{A}))$ en plus de $Pref(W)$.
\begin{equation}
\begin{aligned}
\bigl ( \bigvee_{p\in Q}~ x_{u,p}\land f_p \bigr ) \implies \bigl ( \bigvee_{v\in\mathcal{L}(\mathcal{A}), |v|<=n|Q^\mathcal{A}|}~ x_{v,q}\implies f_q \bigr )
\end{aligned}
\end{equation}\\

\noindent ?

Si $\mathcal{L}(\mathcal{A})$ infini alors je comprends l'utilité de $y$.





\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
\renewcommand{\leftmark}{CONCLUSION}

Mettez votre conclusion ici.  Dressez le bilan de votre travail effectué, en prenant du recul. Discuter de si vous avez bien réussi les objectifs du travail ou non. Présentez les perspectives futurs.

\newpage
%Le style bibliographique utilis
\bibliographystyle{latex8}

%Le fichier .bib uitilis
\bibliography{biblio}

\newpage
\appendix
\addcontentsline{toc}{chapter}{Annexes}

\chapter{Premi\`ere annexe}
\renewcommand{\leftmark}{ANNEXE \thechapter.~~Premi\`ere annexe}
\label{annexe1}

\chapter{Deuxi\`eme annexe}
\renewcommand{\leftmark}{ANNEXE \thechapter.~~Deuxi\`eme annexe}
\label{annexe2}

%%%%%%%FIN-ANNEXES%%%%%%%%%%
\end{document}
