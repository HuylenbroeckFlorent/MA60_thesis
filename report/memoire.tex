\documentclass[12pt,a4paper,oneside, titlepage]{report}

\usepackage{times}
\usepackage[frenchb]{babel}
\usepackage{hyperref} 
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{amsmath} %%
%\usepackage{amsfonts}
%\usepackage{amscd}
%\usepackage{amstext}
\usepackage{amssymb} %%
%\usepackage{bar}
\usepackage{color}
%\usepackage{mathrsfs}
\usepackage{graphicx}
%\usepackage{calligra}
\usepackage{amsthm} % proof
%\usepackage{multirow}
%\usepackage{tabularx}
%\usepackage{layout}
%\pagestyle{headings}
\usepackage{fancyhdr}
\usepackage{pdfpages} %
\usepackage{algorithm} %
\usepackage{algpseudocode} %
\usepackage{makecell} %
\usepackage{tikz} %grahps 
\pagestyle{fancy}

%\setlength{\textheight}{630pt}
%\setlength{\footskip}{30pt}
\newtheorem{defi}{D\'efinition}[section]
\newtheorem{note}{Note}[section]
\newtheorem{proprietet}{Propri\'et\'e}[section]
\newtheorem{exemple}{Exemple}[section]
\newtheorem{corollaire}{Corollaire}[section]
\newtheorem{rem}{Remarque}[section]
\newtheorem{thm}{Th\'eor\`eme}[section]
\newtheorem{illustration}{Illustration}[section]
\newenvironment{demonstration}{\begin{proof}[\textnormal{\textbf{Preuve.}}]}{\end{proof}}
\definecolor{gris}{gray}{0.45}
\setlength{\parindent}{1cm}
\newcommand{\textcalli}[1]{{\small{\textbf{$\negmedspace$\calligra #1}}}}

\renewcommand{\chaptermark}[1]{\markright{\thechapter\ #1}}
%\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % supprime les en-têtes et pieds prédéfinis
\fancyhead[R]{\thepage}% Left Even, Right Odd
\fancyhead[L]{\textsl{\leftmark}} % Left Odd
%\fancyhead[RE]{\textsl{\leftmark}} % Right Even
\renewcommand{\headrulewidth}{0pt}% filet en haut de page
\renewcommand{\footrulewidth}{0pt} % pas de filet en bas
\fancypagestyle{plain}{ % pages de tetes de chapitre
\fancyhead{} % supprime lentete
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0pt} % et le filet
}

\begin{document}
\includepdf{pageGarde.pdf}
%newpage
%\thispagestyle{empty}
%\null
%\newpage
\pagenumbering{roman}
\chapter*{Remerciements}
\renewcommand{\leftmark}{REMERCIEMENTS}
%\addcontentsline{toc}{chapter}{Remerciements}

Nous remercions ...\\

\newpage
\renewcommand{\leftmark}{TABLE DES MATI\`{E}RES}
\thispagestyle{fancy}
\tableofcontents


\newpage
\pagenumbering{arabic}
\renewcommand{\leftmark}{INTRODUCTION}
\chapter{Introduction}
\subsubsection*{Contexte}
\subsubsection*{Définition du problème}
Le probleme dumodel-checking consiste a vérifier qu’un système informatique satisfait une spécification
quand ceux-ci sont donnes sous la forme de modèles mathématiques. Des spècifications typiques sont : est-
ce que le systeme peut atteindre unétat de deadlock ? Est-ce qu’une requète reçoit toujours une reponse ?
Les modeles utilisés peuvent varier : les comportements du système informatique peuventétre modelisè
par un automate acceptant des mots infinis, tandis que la specification peutètre modelisèe par une formule
de logique temporelle LTL.
Plutot que de verifier qu’un système informatique satisfait une spécification, on peut aller plus loin en
envisageant la synthese de controleur. Dans le but de definir les interactions d’un système informatique
avec son environnement, on considere ici un graphe orienté dont les sommets sont partagès entre le système
et l’environnement. Une interaction est alors un chemin infini dans le graphe tel qu’en tout sommet 
systeme (resp. de l’environnement), c’est lui qui décide quel arc suivrea partir de ce sommet. L’objectif
du systeme est, par exemple, d’éviter unètat de deadlock quoique fasse l’environnement, ou encore de
repondrea une requéte quoique fasse l’environnement. Pour y arriver, il a besoin d’une strategie gagnante
qui n’est rien d’autre qu’un programme de controle. La synthese de controleur revient donca construire
(quand c’est possible) une strategie gagnante (contre l’environnement) pour un objectif donnè du système.
Dans ce projet, on propose d’etudier ce problème de synthése pour desjeux de surete´ joues sur graphes.
Pour ces jeux, le systeme a pour objectif d’éviter de passer par certains sommets du graphe.  
\subsubsection*{Présentation et limitations des solutions existantes}
Quand le
graphe est fini, il existe des algorithmes simples qui indiquent si le systeme peut y parvenir et qui dans ce cas
indiquent comment jouer (voir par exemple le livre [1]). Quand le graphe est infini, l’article [2] propose 
algorithme partiel qui utilise des SAT solveurs.
\subsubsection*{Objectif du travail et idées principales}
Dans le cadre du projet, l’etudiant sera amenè´ a comprendre
ces algorithmes et a reproduire les expérimentations de l’article [2], et d’envisager une implèmentation de
calcul de strategie gracea la structure de données “binary decision diagrams” [3,4]
\subsubsection*{Brève description du contenu, chapitre par chapitre}
\newpage


\chapter{Jeux joués sur graphes}\label{ch:1}
\renewcommand{\leftmark}{CHAPITRE \thechapter.~~Jeux joués sur graphes}
\section*{Jeux de sûreté}
Un \emph{jeu de sûreté} se joue sur une \emph{arène} $A = (V_0,V_1,E)$ composée de deux ensembles disjoints, non-vides de sommets $V_0$ et $V_1$, avec $V_0 \cup V_1 = V$, et d'un ensemble d'arêtes $E \subseteq V\times V$. De plus, chaque sommet d'une arène doit posséder au moins un successeur dans l'arène, autre que lui-même.\\
Un tel jeu est défini par un triplet $\mathfrak{G} = (A, I, F)$, avec $A$ une arène, $I\subseteq F$ un ensemble de sommets initiaux et $F\subseteq V$ un ensemble de sommets \emph{sûrs}. \\
Au début de la partie, un pion est placé sur un sommet de l'ensemble $I$.\\
Le jeu est joué par deux \emph{joueurs} numérotés $j_0$ et $j_1$ qui déplacent tour à tour le pion le long des arêtes de l'arène. Une $partie$ d'un jeu est une séquence infinie $\pi=v_0 v_1 ...$ où $v_0\in I, \forall i\in \mathbb{N},v_i \in V, $ et $(v_i, v_{i+1})\in E$.\\
Les coups des joueurs sont décidés par la \emph{stratégie} adoptée par ces derniers. Une stratégie est une fonction $s_{j_n} : V^*V_n\to V$ ($n\in \{0,1\}$) qui indique vers quel sommet déplacer le pion selon la séquence de déplacement précédents.
Une stratégie $s_{j_n}$ est \emph{gagnante} si une partie jouée selon cette stratégie satisfait une condition de victoire pour le joueur $j_n$.
Une partie est dites jouée selon une stratégie $s_{j_n}$ si
$\forall i \in N, v_{i+1} = s_{j_n}(v_0v_1...v_i)$ et $v_i \in V_n$\\
Une stratégie peut être \emph{sans mémoire} $s_{j_n} : V_n \to V$ si elle ne prend en compte que le sommet actuel où se trouve le pion.\\
La \emph{condition de victoire} d'un jeu de sûreté est que tous les sommets visités au cours de la partie soient de l'ensemble $F$. Autrement dit, soit une partie $\pi = v_0v_1...$, $\forall i\in\mathbb{N}, v_i\in F$.\\
Calculer une stratégie gagnante pour un joueur revient généralement à calculer un ensemble gagnant $W\subseteq V$ pour ce joueur.
$$W_n=\{v\in V|j_n\text{ gagne à partir de }v\}$$
Cette définition d'un ensemble gagnant donne immédiatement une stratégie pour le joueur $j_0$. A chaque tour, $j_0$ n'a qu'à bouger le pion vers un sommet dans $W$.
\section*{Jeux d'atteignabilité}
Un \emph{jeu d'atteignabilité} est similaire à un jeu de sûreté $\mathfrak{G} = (A, I, F)$, sauf que $F \subseteq V$ est un ensemble de sommet à atteindre, et donc $I\subseteq V\setminus F$. Une partie $\pi=v_0v_1...$ est donc gagnante pour le joueur $j_0$ si $\exists i \in \mathbb{N}, v_i \in F$


\chapter{Cas fini}
\renewcommand{\leftmark}{CHAPITRE \thechapter.~~Cas fini}
Une \emph{arène finie} est une arène $A=(V_0, V_1, E)$ pour laquelle $V_0$ et $V_1$ sont des ensembles finis.
\section*{Résolution via les attracteurs}
Une méthode pour calculer les ensembles gagnants des jeux de sûreté se base sur le principe d'attracteur. Intéressons nous d'abord au cas des jeux d'atteignabilité :
\begin{defi}
	Soit un jeu d'atteignabilité $\mathfrak{G} = (A, I, F)$ avec $A=(V_0, V_1, E)$ une arène finie, le $i^e$ attracteur pour le joueur $j_n$ est l'ensemble :\\
	$Attr_{j_n}^i=\{v\in V|\text{ le joueur }j_n\text{ peut forcer une visite d'un sommet de }F\text{ depuis }v\text{ en } \leq  i \text{ déplacements}\}$
\end{defi}

%%% INDUCTION ATTRACTEUR
\noindent Construction par induction :
\begin{equation}
\begin{split}
Attr^0_{j_0}(F)&=F\\
Attr^{i+1}_{j_0}(F)&=Attr^i_{j_0}(F)\\
			&\cup \{v'\in V_0|\exists(v,v')\in E:v\in Attr^i_{j_0}(F)\}\\
			&\cup \{v'\in V_1|\forall(v,v')\in E:v\in Attr^i_{j_0}(F)\}
\end{split}
\end{equation}
Par cette construction, on obtient une séquence d'attracteurs $Attr_{j_0}^0(F)\subseteq Attr_{j_0}^1(F) \subseteq ...$ laquelle sera fixe à partir d'une certaine itération $k\leq|V|$ vu que $V$ est un ensemble fini et qu'à chaque itération, au moins un sommet de $V$ est ajouté à l'attracteur. On notera donc $Attr_{j_0}(F)=\bigcup_{i=0}^{|V|}Attr_{j_0}^i$\\


\noindent Cette construction de l'attracteur correspond à l'ensemble gagnant de $j_0$.\\
\begin{demonstration}{
En effet on a que $W_0 \subseteq Attr_{j_0}$ car
\begin{itemize}
\item $\forall v \in Attr_{j_0}^{i+1}\cap V_0, v$ possède un successeur dans $Attr_{j_0}^i$.
\item $\forall v \in Attr_{j_0}^{i+1}\cap V_1,$ tous les successeurs de $v$ sont dans $Attr_{j_0}^i$.
\item $Attr_{j_0}^0(F) \subseteq F$
\end{itemize}
Donc $j_0$ peut gagner la partie à partir de tous les sommets de $W_0$.\\

\noindent Pour montrer que $Attr_{j_0}(F)\subseteq W_0$, il faut montrer que $j_0$ ne peut pas gagner la partie à partir d'un sommet hors de $Attr_{j_0}(F)$, autrement dit que $j_1$ peut forcer le pion à rester en dehors de $Attr_{j_0}(F)$ depuis tout sommet hors de $Attr_{j_0}(F)$.\\
Soit un sommet $v\in V_1\setminus Attr_{j_0}(F)$, alors $v$ possède au moins une arête $(v, v')$ avec $v'\notin Attr_{j_0}(F)$, sinon on aurait $v \in Attr_{j_0}(F)$.\\
Soit  un sommet $v\in V_0\setminus Attr_{j_0}(F)$, alors toutes les arêtes $v$
mènent vers un sommet hors de $Attr_{j_0}(F)$, sinon on aurait $v \in Attr_{j_0}(F)$.\\
Ces deux cas étant exhaustifs, on a bien que $Attr_{j_0}(F)\subseteq W_0$\\

\noindent L'inclusion étant vérifiée dans les deux sens, on a bien que $W_0 = Attr_{j_0}(F)$.\\}
\end{demonstration}


\noindent $Attr_{j_0}(F)$ étant l'ensemble gagnant pour $j_0$, il lui permet d'établir sa stratégie. A chaque tour, le joueur va déplacer le pion d'un sommet de $Attr_{j_0}^{i+1}(F)$ vers un sommet de $Attr_{j_0}^i(F)$ jusqu'à atteindre $Attr_{j_0}^0(F) = F$\\
De cette stratégie découle immédiatement la stratégie pour le joueur $j_1$ : déplacer le pion vers des sommets hors de l'attracteur car, à partir d'un tel sommet, $j_0$ ne peut pas forcer une visite d'un sommet de $F$.

Cette méthode de résolution pour les jeux d'atteignabilité permet aussi de résoudre les jeux de sûreté. Soit un jeu de sûreté $\mathfrak{G} = (A, I, F)$ avec $A$ une arène finie. Si l'on construit $Attr_{j_1}(V\setminus F)$, autrement dit la liste de sommets depuis lesquels $j_1$ peut forcer une visite d'un sommet hors de $F$, on peut en déduire une stratégie pour $j_0$ de manière analogue à la stratégie pour le joueur $j_1$ dans un jeu d'atteignabilité. Il suffit à $j_0$ de ne pas visiter de sommets de cet attracteur. Ainsi, $j_1$ ne pourra pas forcer de visite de $F$.





%%% ALGO ATTRACTEURS
\begin{algorithm}
\caption{Attracteur}\label{attractor}
\hspace*{\algorithmicindent} 
\begin{tabular}{lll}
	\textbf{Entrées} & \textbf{G} : &Graphe, structure de donnée composée d'un tableau à deux\\
	&&dimensions $predecessors$ de prédecesseurs (la liste de \\
	&&prédecesseurs d'un noeud $i$ est stockée à la \\
	&&$i^e$ entrée du tableau) et une liste $players$ (le $i^e$ noeud\\
	&&appartient au joueur dont le numéro figure en \\
	&&$i^e$ entrée de $players$).\\
	&\textbf{F} : &Liste de numéro de sommets.\\
	&\textbf{p} : &Numéro de joueur.\\
	&\textbf{i} : &Nombre d'itération pour la construction de\\
	&&l'attracteur, une valeur négative calculera l'attracteur\\
	&&complet.\\
	\textbf{Sortie} &\multicolumn{2}{l}{$Attr_p^i(F)$}\\
\end{tabular}\\
\begin{algorithmic}[1]
\Procedure{Attractor}{$G, F, p, i$}
	\State $out\_degrees \gets$ tableau de taille $|G|$\Comment Pré-traitement
	\For{$j$ allant de 0 à $|G|-1$}
		\If{$G.players[j] \neq p$}
			\State $out\_degrees[j] \gets $ demi-degré extérieur du noeud $j$
		\EndIf
	\EndFor
	
	\State $attractor \gets$ tableau de taille $|G|$\Comment Initialisation
	\For{$index$ in $F$}
		\State $attractor[index] \gets 1$
	\EndFor
	\State $attractor\_new \gets F$
	
	\While{$attractor\_new$ non-vide \textbf{and} $i\neq 0$}\Comment Calcul de l'attracteur
		\State $to\_check \gets attractor\_new$
		\State $attractor\_new \gets [$ $]$
		\For{$index$ in $to\_check$}
			\For{$pred$ in $G.predecessors[index]$}
				\If{$attractor[pred] = 0$}
					\If{$G.players[pred] = p$}
						\State $attractor\_new.append(pred)$
					\Else
						\State $out\_degrees[pred]\gets out\_degrees[pred]-1$
						\If{$out\_degrees[pred]=0$}
							\State $attractor\_new.append(pred)$
						\EndIf
					\EndIf
				\EndIf
			\EndFor
		\EndFor
	\algstore{attractor}
\end{algorithmic}
\end{algorithm}
\newpage
\begin{algorithm}
\begin{algorithmic}[1]
	\algrestore{attractor}
		\For{$index$ in $attractor\_new$}
			\State $attractor[index]\gets 1$
		\EndFor
		\State $i\gets i-1$
	\EndWhile
	\State\Return $attractor$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection*{Explication}
Cet algorithme se base sur la construction par induction de $Attr_{j_n}^i(F)$.\\
Le cas de départ de la construction se retrouve dans l'étape d'initialisation de l'algorithme. On y ajoute les noeuds de $F$ dans l'attracteur.\\
L'étape du calcul de l'attracteur représente la deuxième étape de la construction. Identifions les 3 éléments de l'union qui constitue $Attr^{i+1}_{j_0}(F)$ dans l'algorithme :
\begin{itemize}
\item $Attr^i_{j_0}(F)$ se retrouve à la ligne 30. A chaque étape on ne crée pas un nouvel attracteur mais on ajoute de nouveaux sommets à l'ancien.
\item $\{v'\in V_0$ $|$ $\exists(v,v')\in E:v\in Attr^i_{j_0}(F)\}$. Dans la boucle intérieure, ligne 19, si un prédecesseur du noeud en cours de traitement appartient au joueur cible, alors il est ajouté à l'attracteur.
\item $\{v'\in V_1$ $|$ $\forall(v,v')\in E:v\in Attr^i_{j_0}(F)\}$. Dans la boucle intérieure, ligne 21, si un prédecesseur du noeud en cours de traitement appartient au joueur ennemi, alors il est ajouté à l'attracteur si tous ses successeurs sont aussi dans l'attracteur. C'est à cette étape que le pré-traitement joue un rôle. Afin de se souvenir de l'appartenance des successeurs du noeud à l'attracteur, on calcule initialement son demi-degré extérieur. Ainsi, à chaque fois qu'un noeud est rencontré dans la liste des prédecesseurs d'un autre noeud, on décremente son demi-degré extérieur. Si cette valeur atteint $0$, cela veut dire que tous les successeurs de ce noeud font partie de l'attracteur (car on ne visite les prédecesseurs d'un noeud que s'il a été ajouté à l'attracteur). On peut donc l'ajouter à son tour à l'attracteur.
\end{itemize}
\subsection*{Complexité}
Considérons un graphe $G$ possédant $n$ noeuds et $m$ arêtes. Alors l'algorithme \emph{Attractor} possède une complexité dans le pire des cas en $O(n+m)$.
\begin{demonstration}
Afin de calculer la complexité totale de l'algorithme, intéressons-nous à la complexité des 3 boucles principales :
\begin{itemize}
\item \textit{Pré-traitement}\\
Le calcul du demi-degré extérieur à l'aide d'une structure de données telle que décrite dans l'entête de l'algorithme se fait en temps $O(m)$. En effet il s'agit d'itérer sur la liste de prédecesseurs et, pour chaque noeud rencontré, incrémenter son demi-degré extérieur. Le graphes possédant $m$ arêtes, il y aura au plus $m$ éléments dans la liste des prédécesseurs.
\item \textit{Initialisation}\\
Cette étape se fait en temps $O(n)$ car il y au plus $n$ noeuds dans le graphes, donc pour lesquels on souhaite construire l'attracteur.
\item \textit{Calcul de l'attracteur}\\
Considérons une valeur de $i$ négative pour le pire des cas. Il y aura au maximum $n$ passages dans la boucle extérieure (ligne 13) car, à chaque étape, $attractor\_new$ doit contenir au moins un noeud de $G$ hors de l'attracteur courant. L'évaluation de la condition d'arrêt se fait en $O(1)$. La boucle à la ligne 16 itère sur les noeuds d'$attractor\_new$ et, pour chacun d'entre eux, la boucle à la ligne 17 va itèrer sur ses prédecesseurs. Toutes les opérations à l'intérieur de cette boucle sont en temps constant $O(1)$. On a donc que, dans le pire des cas, l'algorithme va effectuer des opérations en $O(1)$ pour chaque prédecesseur de chaque noeud de $G$. Finalement, la boucle à la ligne 30 effectuera dans le pire des cas $n$ fois une opération en $O(1)$, car au plus $n$ noeuds seront ajoutés à l'attracteur.\\
Cela nous donne une comlexité en $O(n$ (évaluation de la condition d'arrêt) $+m$ (boucle intérieure) $+n$ (ajout à l'attracteur) $) = O(2n+m) = O(n+m)$.\\
\end{itemize}
Nous obtenons donc une complexité totale de $O(n+m+(n+m)) = O(2(n+m)) = O(n+m)$.
\end{demonstration}
\newpage
\subsection*{Exemple}
Considérons l'arène suivante :

%%% ARENA
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[square] (1) {$1$};
\node[square] (2) [below of=1] {$2$};
\node[round] (3) [right of=1] {$3$};
\node[round] (4) [right of=3] {$4$};
\node[square] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6$};
\node[square] (7) [above of=6] {$7$};
\node[round] (9) [below right of=6] {$9$};
\node[square] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8$};
\node[square] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}

Les noeuds ronds appartiennent au joueur $j_0$, et les carrés à $j_1$. Appliquons l'algorithme \emph{Attractor} sur celui-ci, avec comme ensemble de départ $F=\{1,2,11\}$ (il est intéressant de noter que l'ensemble $F$ ne doit pas forcément être connexe) et pour le joueur $j_0$. De plus nous allons supposer $i$ négatif afin de calculer l'attracteur complet.\\
L'étape de pré-traitement sera rendue visuelle en ajoutant aux noeuds de $j_1$ la valeur correspondant dans le tableau $out\_degrees$. Les noeuds faisant partie de l'attracteur courant $attractor$ seront colorés en gris et ceux étant ajoutés à l'attracteur à l'itération précédente (les noeuds de la liste $attractor\_new$) seront entourés en rouge.
Nous obtenons donc, avant l'entrée dans la boucle principale de l'algorithme, la représentation suivante :\\

%%% ATTR0
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[bcsquare] (1) {$1$};
\node[bcsquare] (2) [below of=1] {$2$};
\node[round] (3) [right of=1] {$3(2)$};
\node[round] (4) [right of=3] {$4(3)$};
\node[square] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(4)$};
\node[square] (7) [above of=6] {$7$};
\node[round] (9) [below right of=6] {$9(2)$};
\node[square] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[bcsquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
Nous avons donc bien $Attr_{j_0}^0(F)=\{1,2,11\}$.\\
La première itération du calcul de l'attracteur va ajouter les noeuds $3$ et $10$ à l'attracteur. En effet, la valeur de $out\_degrees$ de $3$ va être décrémentée deux fois, une fois en suivant les prédecesseurs de $1$ et une autre fois en suivant ceux de $2$. Cette valeur atteignant $0$, il sera ajouté à l'attracteur. La valeur de $out\_degrees$ de $4$ sera aussi décrémentée une fois en partant de $1$. Le cas de $10$ est plus trivial, il appartient à $j_0$ et a été rencontré en suivant les prédecesseurs de $11$, il est donc ajouté à l'attracteur. La valeur de $out\_degrees$ de $9$ est elle aussi décrémentée car le noeud $9$ est un prédecesseur de $11$. Nous obtenons donc la représentation suivante :\\

%%% ATTR1
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[bcround] (3) [right of=1] {$3(0)$};
\node[round] (4) [right of=3] {$4(2)$};
\node[square] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(4)$};
\node[square] (7) [above of=6] {$7$};
\node[round] (9) [below right of=6] {$9(1)$};
\node[bcsquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
Qui correspond à $Attr_{j_0}^1(F)=\{1,2,3,10,11\}$.\\
$5$ possède maintenant un successeur dans l'attracteur, il y sera donc ajouté à l'étape suivante. La valeur de $out\_degrees$ de 4 est décrémentée une fois, car il est prédecesseur de $3$. Le noeud $9$ est atteint une deuxième fois, cette fois depuis $10$. Sa valeur de $out\_degrees$ passant à 0, il est ajouté à l'attracteur.\\
%%% ATTR2
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3(0)$};
\node[round] (4) [right of=3] {$4(1)$};
\node[bcsquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(4)$};
\node[square] (7) [above of=6] {$7$};
\node[bcround] (9) [below right of=6] {$9(0)$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
Nous obtenons $Attr_{j_0}^2(F)=\{1,2,3,5,9,10,11\}$\\
$4$ est atteint une dernière fois car il est prédecesseur de $5$. Sa valeur de $out\_degree$ passant à 0, il est ajouté à l'attracteur. Cette même valeur pour $6$ est décrémentée deux fois lors de cette itération car il est successeur de $5$ et $9$.\\
%%% ATTR3
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3(0)$};
\node[bcround] (4) [right of=3] {$4(0)$};
\node[csquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(2)$};
\node[square] (7) [above of=6] {$7$};
\node[cround] (9) [below right of=6] {$9(0)$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
On obtient $Attr_{j_0}^3(F)=\{1,2,3,4,5,9,10,11\}$\\
La valeur de $out\_degrees$ de $6$ est décrémentée une fois car il est prédecesseur de $4$. Aucun noeud n'est ajouté à $attractor\_new$, l'algorithme s'arrête.\\
%ATTR4
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3$};
\node[cround] (4) [right of=3] {$4$};
\node[csquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6$};
\node[square] (7) [above of=6] {$7$};
\node[cround] (9) [below right of=6] {$9$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
L'attracteur final calculé par l'algorithme est donc $Attr_{j_0}^4(F)=Attr_{j_0}^3(F)=Attr_{j_0}(F)=\{1,2,3,4,5,9,10,11\}$




\chapter{Cas infini}

\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
\renewcommand{\leftmark}{CONCLUSION}

Mettez votre conclusion ici.  Dressez le bilan de votre travail effectué, en prenant du recul. Discuter de si vous avez bien réussi les objectifs du travail ou non. Présentez les perspectives futurs.


%Le style bibliographique utilis
\bibliographystyle{latex8}

%Le fichier .bib uitilis
\bibliography{biblio}

\newpage
\appendix
\addcontentsline{toc}{chapter}{Annexes}

\chapter{Premi\`ere annexe}
\renewcommand{\leftmark}{ANNEXE \thechapter.~~Premi\`ere annexe}
\label{annexe1}

\chapter{Deuxi\`eme annexe}
\renewcommand{\leftmark}{ANNEXE \thechapter.~~Deuxi\`eme annexe}
\label{annexe2}

%%%%%%%FIN-ANNEXES%%%%%%%%%%
\end{document}
