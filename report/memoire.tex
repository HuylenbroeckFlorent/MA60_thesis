\documentclass[12pt,a4paper,oneside,titlepage]{report}

\usepackage{times}
\usepackage[frenchb]{babel}
\usepackage{hyperref} 
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{amsmath} %%
%\usepackage{amsfonts}
%\usepackage{amscd}
%\usepackage{amstext}
\usepackage{amssymb} %%
%\usepackage{bar}
\usepackage{color}
%\usepackage{mathrsfs}
\usepackage{graphicx}
%\usepackage{calligra}
\usepackage{amsthm} % proof
%\usepackage{multirow}
%\usepackage{tabularx}
%\usepackage{layout}
%\pagestyle{headings}
\usepackage{fancyhdr}
\usepackage{pdfpages} %
\usepackage{algorithm} %
\usepackage{algpseudocode} %
\usepackage{makecell} %
\usepackage{tikz} %grahps 
\usepackage{float} %force algorithm in place
\pagestyle{fancy}

%\setlength{\textheight}{630pt}
%\setlength{\footskip}{30pt}
\newtheorem{defi}{D\'efinition}[section]
\newtheorem{note}{Note}[section]
\newtheorem{proprietet}{Propri\'et\'e}[section]
\newtheorem{exemple}{Exemple}[section]
\newtheorem{corollaire}{Corollaire}[section]
\newtheorem{rem}{Remarque}[section]
\newtheorem{thm}{Th\'eor\`eme}[section]
\newtheorem{illustration}{Illustration}[section]
\newenvironment{demonstration}{\begin{proof}[\textnormal{\textbf{Preuve.}}]}{\end{proof}}
\definecolor{gris}{gray}{0.45}
\setlength{\parindent}{1cm}
\newcommand{\textcalli}[1]{{\small{\textbf{$\negmedspace$\calligra #1}}}}

\renewcommand{\chaptermark}[1]{\markright{\thechapter\ #1}}
%\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % supprime les en-têtes et pieds prédéfinis
\fancyhead[R]{\thepage}% Left Even, Right Odd
\fancyhead[L]{\textsl{\leftmark}} % Left Odd
%\fancyhead[RE]{\textsl{\leftmark}} % Right Even
\renewcommand{\headrulewidth}{0pt}% filet en haut de page
\renewcommand{\footrulewidth}{0pt} % pas de filet en bas
\fancypagestyle{plain}{ % pages de tetes de chapitre
\fancyhead{} % supprime lentete
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0pt} % et le filet
}

\begin{document}
\includepdf{pageGarde.pdf}
%newpage
%\thispagestyle{empty}
%\null
%\newpage
\pagenumbering{roman}
\chapter*{Remerciements}
\renewcommand{\leftmark}{REMERCIEMENTS}
%\addcontentsline{toc}{chapter}{Remerciements}

Nous remercions ...\\

\newpage
\renewcommand{\leftmark}{TABLE DES MATI\`{E}RES}
\thispagestyle{fancy}
\tableofcontents


\newpage
\pagenumbering{arabic}
\renewcommand{\leftmark}{INTRODUCTION}
\chapter{Introduction}
\subsubsection*{Contexte}
\subsubsection*{Définition du problème}
Le probleme dumodel-checking consiste a vérifier qu’un système informatique satisfait une spécification
quand ceux-ci sont donnes sous la forme de modèles mathématiques. Des spècifications typiques sont : est-
ce que le systeme peut atteindre unétat de deadlock ? Est-ce qu’une requète reçoit toujours une reponse ?
Les modeles utilisés peuvent varier : les comportements du système informatique peuventétre modelisè
par un automate acceptant des mots infinis, tandis que la specification peutètre modelisèe par une formule
de logique temporelle LTL.
Plutot que de verifier qu’un système informatique satisfait une spécification, on peut aller plus loin en
envisageant la synthese de controleur. Dans le but de definir les interactions d’un système informatique
avec son environnement, on considere ici un graphe orienté dont les sommets sont partagès entre le système
et l’environnement. Une interaction est alors un chemin infini dans le graphe tel qu’en tout sommet 
systeme (resp. de l’environnement), c’est lui qui décide quel arc suivrea partir de ce sommet. L’objectif
du systeme est, par exemple, d’éviter unètat de deadlock quoique fasse l’environnement, ou encore de
repondrea une requéte quoique fasse l’environnement. Pour y arriver, il a besoin d’une strategie gagnante
qui n’est rien d’autre qu’un programme de controle. La synthese de controleur revient donca construire
(quand c’est possible) une strategie gagnante (contre l’environnement) pour un objectif donnè du système.
Dans ce projet, on propose d’etudier ce problème de synthése pour desjeux de surete´ joues sur graphes.
Pour ces jeux, le systeme a pour objectif d’éviter de passer par certains sommets du graphe.  
\subsubsection*{Présentation et limitations des solutions existantes}
Quand le
graphe est fini, il existe des algorithmes simples qui indiquent si le systeme peut y parvenir et qui dans ce cas
indiquent comment jouer (voir par exemple le livre [1]). Quand le graphe est infini, l’article [2] propose 
algorithme partiel qui utilise des SAT solveurs.
\subsubsection*{Objectif du travail et idées principales}
Dans le cadre du projet, l’etudiant sera amenè´ a comprendre
ces algorithmes et a reproduire les expérimentations de l’article [2], et d’envisager une implèmentation de
calcul de strategie gracea la structure de données “binary decision diagrams” [3,4]
\subsubsection*{Brève description du contenu, chapitre par chapitre}
\newpage

\chapter{Jeux joués sur graphes}\label{ch:1}
\renewcommand{\leftmark}{CHAPITRE \thechapter.~~Jeux joués sur graphes}
Dans ce chapitre, nous allons présenter les jeux joués sur graphes.
\section{Arènes}
Une \emph{arène} est un graphe $A = (V_0,V_1,E)$ composée de deux ensembles disjoints, non-vides de sommets $V_0$ et $V_1$, avec $V_0 \cup V_1 = V$, et d'un ensemble d'arcs $E \subseteq V\times V$. De plus, chaque sommet d'une arène doit posséder au moins un successeur dans l'arène.\\

\noindent Voici un exemple d'arène :\\

\begin{figure}[H]
\centering
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},			
						square/.style = {draw, rectangle, minimum size=10mm}
					]
\node[square] (1) {$1$};
\node[square] (2) [below of=1] {$2$};
\node[round] (3) [right of=1] {$3$};
\node[round] (4) [right of=3] {$4$};
\node[square] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6$};
\node[square] (7) [above of=6] {$7$};
\node[round] (9) [below right of=6] {$9$};
\node[square] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8$};
\node[square] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}
\caption{Exemple d'une arène}
\label{fig:arena}
\end{figure}
\noindent L'ensemble $V_0$ est représenté par les sommets carrés, $V_1$ par les sommets ronds et $E$ par les flèches reliant les sommets.
\section{Coups, parties et objectifs}
Au début de la partie, un \emph{pion} est placé sur un sommet du graphe. Ce pion est un marquage d'un sommet de l'arène qui va être modifié tour à tour par les joueurs. Dans la suite de ca rapport, \emph{déplacer le pion} réferera à l'action de retirer le marquage du sommet courant, et de marquer un autre sommet du graphe.\\
Le jeu est joué par deux \emph{joueurs} numérotés $j_0$ et $j_1$ qui déplacent le pion le long des arcs de l'arène. Le joueur qui déplace le pion est le joueur à qui appartient le sommet courant où se trouve le pion. Un \emph{coup} est l'action d'un joueur de déplacer le pion le long d'un arc du graphe, depuis un sommet lui appartenant, vers un de ses successeurs.\\
Une séquence de coups forme une \emph{partie}.
\begin{defi}
	Une \emph{partie} d'un jeu est une séquence infinie $\pi=v_0 v_1 ...$ où $\forall i\in \mathbb{N},v_i \in V, $ et $(v_i, v_{i+1})\in E$.
\end{defi}
\noindent L'\emph{objectif} $\Omega$ d'un jeu joué sur graphes est ce qui va définir la condition de victoire des joueurs. Dans ce rapport nous allons nous intèresser à deux types de jeux, les jeux de sûretés et les jeux d'atteignabilité. Les objectifs pour ces deux types de jeux sont définis par un sous ensemble $F\subseteq V$.
\subsection{Jeux de sûreté}
Un jeu de sûreté est défini par un tuple $\mathfrak{G}=(A,F)$ avec $A$ une arène et $F\subseteq V$ un sous ensemble de sommets dits \emph{sûrs}. L'objectif d'un jeu de sûreté est que tous les sommets visités lors de la partie soient des sommets sûrs.
\begin{defi}
Soit $\mathfrak{G}=(A,F)$ un jeu de sûreté, une partie $\pi=v_0v_1...$ est gagnante pour le joueur $j_0$ si $\forall i\in \mathbb{N}, v_i \in F$
\end{defi}
\subsection{Jeux d'atteignabilité}
Un jeu d'atteignabilité est défini par un tuple $\mathfrak{G}=(A,F)$ avec $A$ une arène et $F\subseteq V$ un sous ensemble de sommets \emph{à atteindre}. L'objectif d'un jeu de sûreté est qu'au moins un sommet de $F$ soit visité au cours de la partie. 
\begin{defi}
Soit $\mathfrak{G}=(A,F)$ un jeu d'atteignabilité, une partie $\pi=v_0v_1...$ est gagnante pour le joueur $j_0$ si $\exists i\in \mathbb{N}, v_i \in F$
\end{defi}
\noindent Les jeux d'atteignabilité sont complémentaires aux jeux de sûreté.

\section{Stratégies et ensembles gagnants}
\noindent Les coups des joueurs sont décidés par la \emph{stratégie} adoptée par ces derniers. Une stratégie est une fonction $s_{j_n} : V^*V_n\to V$ qui indique vers quel sommet le joueur $j_n$ va déplacer le pion depuis le sommet courant $v\in V_n$ selon la séquence de déplacement précédents.\\
Une stratégie peut être \emph{sans mémoire} $s_{j_n} : V_n \to V$ si elle ne prend en compte que le sommet actuel où se trouve le pion.\\

\noindent Une stratégie $s_{j_n}$ est \emph{gagnante} pour le joueur $j_n$ si toutes parties \emph{jouées selon cette stratégie} mènent à une victoire du joueur $j_n$.
\begin{defi}
Une partie $\pi=v_0 v_1 ...$ est dite \emph{jouée selon une stratégie} $s_{j_n}$ si $\forall i \in \mathbb{N}, v_{i+1} = s_{j_n}(v_0v_1...v_i)$ et $v_i \in V_n$
\end{defi}

\noindent La notion de stratégie gagnante nous permet de définir un \emph{ensemble gagnant}. 
\begin{defi}
Soit $\mathfrak{G}=(A,F)$ un jeu, avec $A=(V_0, V_1, E)$, l'\emph{ensemble gagnant} $W\subseteq V$ est l'ensemble $W=\{v\in V$ $|$ $j_0$ possède une stratégie gagnante à partir de $v \}$
\end{defi}


\chapter{Cas fini}
\renewcommand{\leftmark}{CHAPITRE \thechapter.~~Cas fini}
Afin de résoudre les jeux de sûreté joués sur des graphes, nous allons distinguer les arènes possédant un nombre fini de sommet de celles en possèdant un nombre infini. 
\begin{defi}
Une \emph{arène finie} est une arène $A=(V_0, V_1, E)$ pour laquelle $V_0$ et $V_1$ sont des ensembles finis.
\end{defi}
\noindent Dans cette section, nous allons définir la notion d'attracteur, et l'appliquer afin de calculer les régions gagnantes des arènes finies, afin d'en déterminer les stratégies gagnantes des deux joueurs. Nous allons aussi proposer un algorithme qui calcule les attracteurs d'une arène finie.
\section{Résolution via les attracteurs}
Une méthode pour calculer les ensembles gagnants des jeux de sûreté et d'atteignabilité se base sur le principe d'attracteur. 
\begin{defi}
	Soit un jeu $\mathfrak{G} = (A,F)$ avec $A=(V_0, V_1, E)$ une arène finie et $F$ un sous ensemble de sommets tel que $F\subseteq V$, soit $i\in \mathbb{N}$, le $i^e$ attracteur pour le joueur $j_n$ est l'ensemble :\\
	$Attr_{j_n}^i=\{v\in V$ $|$ le joueur $j_n$ peut forcer une visite d'un sommet de $F
$ depuis $v$ en $ \leq  i $ déplacements$\}$
\end{defi}

%%% INDUCTION ATTRACTEUR
\noindent Afin de construire cet objet en incrémentant la valeur de $i$, \cite{Church} nous donne la formule de construction par induction suivante :
\begin{equation}
\begin{split}
Attr^0_{j_n}(F)&=F\\
Attr^{i+1}_{j_n}(F)&=Attr^i_{j_n}(F)\\
			&\cup \{v'\in V_n\text{ }|\text{ }\exists(v,v')\in E:v\in Attr^i_{j_0}(F)\}\\
			&\cup \{v'\in V\setminus V_n\text{ }|\text{ }\forall(v,v')\in E:v\in Attr^i_{j_0}(F)\}
\end{split}
\end{equation}
\noindent L'intuition derrière cette formule est la suivante :\\
En 0 coups, le joueur $j_n$ ne peut forcer une visite d'un sommet de $F$ que depuis un sommet de $F$. On a donc que l'attracteur de départ, $Attr^0_{j_n}(F)$ ne contient que les sommets de $F$.\\
Ensuite, en incrémentant le nombre de coups, autrement dit la valeur de $i$, on va considérer l'ajout des sommets qui sont des prédecesseurs des sommets de l'attracteur courant, car ceux ci mettront, dans le pire des cas, un coup de plus à atteindre un sommet de $F$. Donc, si un sommet est prédecesseur d'un sommet de l'attracteur sans en faire partie lui-même, il y a deux possibilités (correspondant aux deux ensembles unis à $Attr^i_{j_n}(F)$ dans la formule 3.1). Soit le sommet appartient à $j_n$ et ce sera à lui de jouer un coup à partir de ce sommet. Il pourra ainsi décider de s'approcher d'un sommet de $F$. Il ne faut donc qu'un seul successeur dans l'attracteur courant pour être ajouté à l'attracteur suivant. Par contre si le sommet appartient au joueur opposé à $j_n$, alors il faut s'assurer que peu importe le coup qu'il joue, il se rapproche d'un sommet de $F$. Il est donc nécessaire que tous les successeurs du sommet soient dans $Attr^i_{j_n}(F)$ pour quel sommet soit ajouté à l'attracteur suivant.


Par cette construction, on obtient une séquence d'attracteurs $Attr_{j_n}^0(F)\subseteq Attr_{j_n}^1(F) \subseteq ...$ laquelle sera fixe à partir d'une certaine itération $k\leq|V|$ vu que $V$ est un ensemble fini et qu'à chaque itération, au moins un sommet de $V$ est ajouté à l'attracteur. On notera $Attr_{j_n}(F)=\bigcup_{i=0}^{|V|}Attr_{j_n}^i(F)$

\begin{thm} 
	Pour un jeu d'atteignabilité, cette construction de l'attracteur pour $j_0$ vers $F$ donnera l'ensemble gagnant de $j_0$.
\end{thm}
\begin{demonstration}{
En effet on a que $Attr_{j_0}(F)\subseteq W_0 $ car
\begin{itemize}
\item $\forall v \in Attr_{j_0}^{i+1}\cap V_0, v$ possède un successeur dans $Attr_{j_0}^i$.
\item $\forall v \in Attr_{j_0}^{i+1}\cap V_1,$ tous les successeurs de $v$ sont dans $Attr_{j_0}^i$.
\item $Attr_{j_0}^0(F) \subseteq F$
\end{itemize}
Donc $j_0$ peut gagner la partie à partir de tous les sommets de $Attr_{j_0}(F)$. Il lui suffit, à chaque coups depuis un sommet de $Attr^{i+1}_{j_0}(F)$, de déplacer le pion vers un sommet dans $Attr^{i}_{j_0}(F)$ afin de se rapprocher progressivement de $Attr_{j_0}^0(F) \subseteq F$, ce qui est possible par la manière dont est construit l'attracteur. Cette construction explique aussi que le joueur opposé sera forcé d'en faire autant. Cette stratégie est donc gagnante pour $j_0$ depuis chaque sommet de l'attracteur.\\

\noindent Pour montrer que $W_0\subseteq Attr_{j_0}(F)$, il faut montrer que $j_0$ ne peut pas gagner la partie à partir d'un sommet hors de $Attr_{j_0}(F)$, autrement dit que $j_1$ peut forcer le pion à rester en dehors de $Attr_{j_0}(F)$ depuis tout sommet hors de $Attr_{j_0}(F)$.\\
Soit un sommet $v\in V_1\setminus Attr_{j_0}(F)$, alors $v$ possède au moins une arête $(v, v')$ avec $v'\notin Attr_{j_0}(F)$, sinon on aurait $v \in Attr_{j_0}(F)$. La stratégie gagnante pour $j_1$ est donc de déplacer le pion le long de cet arc afin de rester hors de l'attracteur.\\
Soit  un sommet $v\in V_0\setminus Attr_{j_0}(F)$, alors toutes les arêtes $v$
mènent vers un sommet hors de $Attr_{j_0}(F)$, sinon on aurait $v \in Attr_{j_0}(F)$. $j_0$ ne peut donc pas entrer dans l'attracteur depuis ce sommet et ne peut donc pas forcer de visite d'un sommet de $F$ depuis ce sommet.
Ces deux cas étant exhaustifs, et ayant montré que $j_0$ est contraint de rester hors de l'attracteur dans ces deux cas, on a bien que $W_0\subseteq Attr_{j_0}(F)$

\noindent L'inclusion étant vérifiée dans les deux sens, on en déduit $W_0 = Attr_{j_0}(F)$.}
\end{demonstration}
Ainsi nous avons montré que l'on peut construire l'ensemble gagnant $W_0$ du joueur $j_0$ pour un jeu d'atteignabilité en utilisant le principe d'attracteur. On obtient aussi immédiatement l'ensemble gagnant $W_1=V\setminus W_0$ du joueur $j_1$. Chaque joueur peut gagner la partie à partir de chaque sommet de leur ensemble gagnant respectif en adoptant les stratégies énoncée ci-dessus.\\
De plus, la dualité entre un jeu d'atteignabilité et un jeu de sûreté nous permet d'énoncer le théorème suivant :

\begin{thm}
	Cette méthode de résolution pour les jeux d'atteignabilité permet aussi de résoudre les jeux de sûreté. 
\label{thm:dualite}
\end{thm}
\begin{demonstration}
Soit un jeu de sûreté $\mathfrak{G} = (A, F)$ avec $A$ une arène finie. on construit $Attr_{j_1}(V\setminus F)$, autrement dit la liste de sommets depuis lesquels $j_1$ peut forcer une visite d'un sommet hors de $F$. En adoptant la même stratégie que $j_0$ dans un jeu d'atteignabilité, cet attracteur donne l'ensemble gagnant de $j_1$ pour un jeu de sûreté. De manière analogue, $j_0$, en adoptant la stratégie du joueur $j_1$ du jeu d'atteignabilité, ne pourra gagner le jeu de sûreté que depuis les sommets hors de cet attracteur.
\end{demonstration}
\noindent La figure suivante représente, en gris, l'ensemble gagnant du joueur $j_0$ d'un jeu d'atteignabilité joue sur l'arène de la figure \ref{fig:arena}, avec $F=\{1,2,11\}$.
\begin{figure}[H]
\centering
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3$};
\node[cround] (4) [right of=3] {$4$};
\node[csquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6$};
\node[square] (7) [above of=6] {$7$};
\node[cround] (9) [below right of=6] {$9$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
\caption{Illustration d'un ensemble gagnant}
\end{figure}
\newpage

\section{Algorithme}
Nous allons maintenant proposer un algorithme de calcul du $i^e$ attracteur. Pour faciliter la lecture, l'algorithme sera découpé en 3 phases suivies d'explications.
%%% ALGO ATTRACTEURS
\begin{algorithm}[H]
\caption{Attracteur}\label{attractor}
\hspace*{\algorithmicindent} 
\begin{tabular}{lll}
	\textbf{Entrées} & \textbf{G} : &Graphe, structure de donnée composée d'un tableau à deux\\
	&&dimensions $predecessors$ de prédecesseurs (la liste de \\
	&&prédecesseurs d'un noeud $i$ est stockée à la \\
	&&$i^e$ entrée du tableau) et une liste $players$ (le $i^e$ noeud\\
	&&appartient au joueur dont le numéro figure en \\
	&&$i^e$ entrée de $players$).\\
	&\textbf{F} : &Liste de numéro de sommets.\\
	&\textbf{p} : &Numéro de joueur.\\
	&\textbf{i} : &Nombre d'itération pour la construction de\\
	&&l'attracteur, une valeur négative calculera l'attracteur\\
	&&complet.\\
	\textbf{Sortie} &\multicolumn{2}{l}{$Attr_p^i(F)$}\\
\end{tabular}\\
\begin{algorithmic}[1]
\Procedure{Attractor}{$G, F, p, i$}
	\State $out\_degrees \gets$ tableau de taille $|G|$\Comment Pré-traitement
	\For{$j$ allant de 0 à $|G|-1$}
		\If{$G.players[j] \neq p$}
			\For{$pred$ in $G.predecessors[j]$}
				\State $out\_degrees[pred] \gets out\_degrees[pred]+1$
			\EndFor
		\EndIf
	\EndFor
\algstore{attractor}
\end{algorithmic}
\end{algorithm}
L'algorithme commence par une phase de pré-traitement au cours de laquelle on va calculer le \emph{demi-degré extérieur} (le nombre d'arcs sortant) de chaque noeud n'appartenant pas au joueur $p$. Pour cela, on initialise une liste $out\_degrees$ de la taille du nombre de noeuds du graphe. Ensuite, on parcours le tableau des prédecesseurs du graphe $G.predecessors$. On incrémente l'indice de $out\_degrees$ correspondant à chaque noeud rencontré dans ce tableau car s'il est prédécesseur d'un autre noeud, alors un arc en sort pour aller vers celui-ci.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\algrestore{attractor}
	\State $attractor \gets$ tableau de taille $|G|$\Comment Initialisation
	\For{$index$ in $F$}
		\State $attractor[index] \gets 1$
	\EndFor
	\State $attractor\_new \gets F$
\algstore{attractor}
\end{algorithmic}
\end{algorithm}
On initialise ensuite le tableau $attractor$ qui va indiquer quels sommets sont marqués comme appartenant a l'attracteur courant. On y marque les sommets de $F$. Cette étape correspond au calcul de $Attr^0_p(F)$.\\
On initialise ensuite la liste $attractor\_new$. Cette liste va contenir, après chaque itération de la boucle principale, les sommets qui ont été ajoutés à l'attracteur lors de cette itération. On ajoute initialement les sommets de $F$ à cette liste car $Attr^0_p(F)$ est déjà calculé.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\algrestore{attractor}
	\While{$attractor\_new$ non-vide \textbf{and} $i\neq 0$}\Comment Calcul de l'attracteur
		\State $to\_check \gets attractor\_new$
		\State $attractor\_new \gets [$ $]$
		\For{$index$ in $to\_check$}
			\For{$pred$ in $G.predecessors[index]$}
				\If{$attractor[pred] = 0$}
					\If{$G.players[pred] = p$}
						\State $attractor\_new.append(pred)$
					\Else
						\State $out\_degrees[pred]\gets out\_degrees[pred]-1$
						\If{$out\_degrees[pred]=0$}
							\State $attractor\_new.append(pred)$
						\EndIf
					\EndIf
				\EndIf
			\EndFor
		\EndFor
		\For{$index$ in $attractor\_new$}
			\State $attractor[index]\gets 1$
		\EndFor
		\State $i\gets i-1$
	\EndWhile
	\State\Return $attractor$
\EndProcedure
\end{algorithmic}
\end{algorithm}
La boucle principale de cet algorithme se base sur la construction par induction de $Attr_{j_n}^i(F)$. On y retrouve les 3 éléments de l'union qui constitue $Attr^{i+1}_{j_n}(F)$ :
\begin{itemize}
\item $Attr^i_{j_n}(F)$ se retrouve à la ligne 32. A chaque étape on ne crée pas un nouvel attracteur mais on marque dans $attractor$ les nouveaux sommets présents dans $attractor\_new$.
\item $\{v'\in V_n$ $|$ $\exists(v,v')\in E:v\in Attr^i_{j_n}(F)\}$. Dans la boucle intérieure, ligne 21, si un prédecesseur du noeud en cours de traitement appartient au joueur cible, alors il est ajouté à $attractor\_new$ afin d'être ajouté à l'attracteur.
\item $\{v'\in V\setminus V_n$ $|$ $\forall(v,v')\in E:v\in Attr^i_{j_n}(F)\}$. Dans la boucle intérieure, ligne 23, si un prédecesseur du noeud en cours de traitement n'appartient pas à $p$, alors il est ajouté à l'attracteur si tous ses successeurs sont aussi dans l'attracteur. C'est à cette étape que le pré-traitement joue un rôle. A chaque fois qu'un noeud est rencontré dans la liste des prédecesseurs d'un autre noeud, on décremente la valeur correspondante dans $out\_degrees$. Si cette valeur atteint $0$, cela veut dire que tous les successeurs de ce noeud font partie de l'attracteur (car on ne visite les prédecesseurs d'un noeud que s'il a été ajouté à l'attracteur et on y ajoute chaque noeud qu'une fois). On peut donc l'ajouter à son tour à l'attracteur.
\end{itemize}
Le calcul s'arrête quand aucun noeud n'est ajouté à l'attracteur au cours d'une itération ($attractor\_new$ est vide). Cela veut dire que le point fixe de la séquence d'attracteur $Attr^0_p(F)\subseteq Attr^1_p(F)\subseteq ...$ est atteint et que l'attracteur complet a été calculé.\\
L'algorithme peut aussi retourner le $i^e$ attracteur si on lui passe en argument une valeur de $i$ positive (et inférieure au nombre d'itération qu'il faut pour atteindre le point fixe). En effet, $i$ intervient dans le calcul de la condition d'arrêt. Celui-ci est décrémenté à chaque nouvel attracteur calculé. Cependant, la condition d'arrêt ne vérifie qui si $i\neq 0$. Une valeur négative de $i$ en entrée assurera donc le calcul de l'attracteur complet, car celui-ci ne causera pas l'arrêt de la boucle principale.
\subsection{Complexité}
Considérons un graphe $G$ possédant $n$ noeuds et $m$ arêtes. Alors l'algorithme \emph{Attractor} possède une complexité dans le pire des cas en $O(n+m)$.
\begin{demonstration}
Afin de calculer la complexité totale de l'algorithme, intéressons-nous à la complexité des 3 boucles principales :
\begin{itemize}
\item \textit{Pré-traitement}\\
Le calcul du demi-degré extérieur à l'aide d'une structure de données telle que décrite dans l'entête de l'algorithme se fait en temps $O(m)$. En effet il s'agit d'itérer sur la liste de prédecesseurs et, pour chaque noeud rencontré, incrémenter son demi-degré extérieur. Le graphes possédant $m$ arêtes, il y aura au plus $m$ éléments dans la liste des prédécesseurs.
\item \textit{Initialisation}\\
Cette étape se fait en temps $O(n)$ car il y au plus $n$ noeuds dans le graphes, donc pour lesquels on souhaite construire l'attracteur.
\item \textit{Calcul de l'attracteur}\\
Considérons une valeur de $i$ négative pour le pire des cas. Il y aura au maximum $n$ passages dans la boucle extérieure (ligne 15) car, à chaque étape, $attractor\_new$ doit contenir au moins un noeud de $G$ hors de l'attracteur courant. L'évaluation de la condition d'arrêt se fait en $O(1)$. La boucle à la ligne 18 itère sur les noeuds d'$attractor\_new$ et, pour chacun d'entre eux, la boucle à la ligne 19 va itèrer sur ses prédecesseurs. Toutes les opérations à l'intérieur de cette boucle sont en temps constant $O(1)$. On a donc que, dans le pire des cas, l'algorithme va effectuer des opérations en $O(1)$ pour chaque prédecesseur de chaque noeud de $G$. Finalement, la boucle à la ligne 32 effectuera dans le pire des cas $n$ fois une opération en $O(1)$, car au plus $n$ noeuds seront ajoutés à l'attracteur.\\
Cela nous donne une comlexité en $O(n$ (évaluation de la condition d'arrêt) $+m$ (boucle intérieure) $+n$ (ajout à l'attracteur) $) = O(2n+m) = O(n+m)$.\\
\end{itemize}
Nous obtenons donc une complexité totale de $O(n+m+(n+m)) = O(2(n+m)) = O(n+m)$.
\end{demonstration}
\newpage
\subsection{Exemple}
Afin d'illustrer le fonctionnement de l'algorithme, considérons l'arène de la figure \ref{fig:arena} et calculons l'attracteur pour le joueur $j_0$ avec  $F=\{1,2,11\}$, dans le but de calculer les ensembles gagnants des deux joueurs pour un jeu d'atteignabilité. Supposons $i$ négatif afin de calculer l'attracteur complet.\\
L'étape de pré-traitement sera rendue visuelle en ajoutant aux noeuds de $j_1$ la valeur correspondant dans le tableau $out\_degrees$. Les noeuds faisant partie de l'attracteur courant $attractor$ seront colorés en gris et ceux étant ajoutés à l'attracteur à l'itération précédente (les noeuds de la liste $attractor\_new$) seront entourés en rouge.
Nous obtenons donc, avant l'entrée dans la boucle principale de l'algorithme, la représentation suivante :\\

%%% ATTR0
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[bcsquare] (1) {$1$};
\node[bcsquare] (2) [below of=1] {$2$};
\node[round] (3) [right of=1] {$3(2)$};
\node[round] (4) [right of=3] {$4(3)$};
\node[square] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(4)$};
\node[square] (7) [above of=6] {$7$};
\node[round] (9) [below right of=6] {$9(2)$};
\node[square] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[bcsquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
Nous avons donc bien $Attr_{j_0}^0(F)=\{1,2,11\}$.\\
La première itération du calcul de l'attracteur va ajouter les noeuds $3$ et $10$ à l'attracteur. En effet, la valeur de $out\_degrees$ de $3$ va être décrémentée deux fois, une fois en suivant les prédecesseurs de $1$ et une autre fois en suivant ceux de $2$. Cette valeur atteignant $0$, il sera ajouté à l'attracteur. La valeur de $out\_degrees$ de $4$ sera aussi décrémentée une fois en partant de $1$. Le cas de $10$ est plus trivial, il appartient à $j_0$ et a été rencontré en suivant les prédecesseurs de $11$, il est donc ajouté à l'attracteur. La valeur de $out\_degrees$ de $9$ est elle aussi décrémentée car le noeud $9$ est un prédecesseur de $11$. Nous obtenons donc la représentation suivante :\\

%%% ATTR1
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[bcround] (3) [right of=1] {$3(0)$};
\node[round] (4) [right of=3] {$4(2)$};
\node[square] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(4)$};
\node[square] (7) [above of=6] {$7$};
\node[round] (9) [below right of=6] {$9(1)$};
\node[bcsquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
Qui correspond à $Attr_{j_0}^1(F)=\{1,2,3,10,11\}$.\\
$5$ possède maintenant un successeur dans l'attracteur, il y sera donc ajouté à l'étape suivante. La valeur de $out\_degrees$ de 4 est décrémentée une fois, car il est prédecesseur de $3$. Le noeud $9$ est atteint une deuxième fois, cette fois depuis $10$. Sa valeur de $out\_degrees$ passant à 0, il est ajouté à l'attracteur.\\
%%% ATTR2
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3(0)$};
\node[round] (4) [right of=3] {$4(1)$};
\node[bcsquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(4)$};
\node[square] (7) [above of=6] {$7$};
\node[bcround] (9) [below right of=6] {$9(0)$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
Nous obtenons $Attr_{j_0}^2(F)=\{1,2,3,5,9,10,11\}$\\
$4$ est atteint une dernière fois car il est prédecesseur de $5$. Sa valeur de $out\_degree$ passant à 0, il est ajouté à l'attracteur. Cette même valeur pour $6$ est décrémentée deux fois lors de cette itération car il est successeur de $5$ et $9$.\\
%%% ATTR3
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3(0)$};
\node[bcround] (4) [right of=3] {$4(0)$};
\node[csquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6(2)$};
\node[square] (7) [above of=6] {$7$};
\node[cround] (9) [below right of=6] {$9(0)$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8(1)$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
On obtient $Attr_{j_0}^3(F)=\{1,2,3,4,5,9,10,11\}$\\
La valeur de $out\_degrees$ de $6$ est décrémentée une fois car il est prédecesseur de $4$. Aucun noeud n'est ajouté à $attractor\_new$, l'algorithme s'arrête.\\
%ATTR4
\begin{tikzpicture}[	
						node distance={20mm},
						round/.style = {draw, circle, minimum size=12mm},
						cround/.style = {draw, fill=gray!25, circle, minimum size=12mm},
						bround/.style = {draw=red!75, very thick, circle, minimum size=12mm},
						bcround/.style = {draw=red!75, very thick, fill=gray!25, circle, minimum size=12mm},
						square/.style = {draw, rectangle, minimum size=10mm},
						csquare/.style = {draw, fill=gray!25, rectangle, minimum size=10mm},
						bsquare/.style = {draw=red!75, very thick, rectangle, minimum size=10mm},
						bcsquare/.style = {draw=red!75, very thick, fill=gray!25, rectangle, minimum size=10mm}
					]
\node[csquare] (1) {$1$};
\node[csquare] (2) [below of=1] {$2$};
\node[cround] (3) [right of=1] {$3$};
\node[cround] (4) [right of=3] {$4$};
\node[csquare] (5) [below of=4] {$5$};
\node[round] (6) [right of=4] {$6$};
\node[square] (7) [above of=6] {$7$};
\node[cround] (9) [below right of=6] {$9$};
\node[csquare] (10) [above right of=9] {$10$};
\node[round] (8) [above of=10] {$8$};
\node[csquare] (11) [right of=10] {$11$};

\draw[->] (1) -- (2);
\draw[->] (2) -- (5);
\draw[->] (3) -- (1);
\draw[->] (3) -- (2);
\draw[->] (4) to [out=135, in=45] (1);
\draw[->] (4) -- (3);
\draw[->] (4) -- (5);
\draw[->] (5) -- (3);
\draw[->] (5) to [out=60, in=210] (6);
\draw[->] (6) -- (4);
\draw[->] (6) to [out=240, in=30] (5);
\draw[->] (6) to [out=135, in=225] (7);
\draw[->] (6) -- (9);
\draw[->] (6) to [out=22, in=225] (8);
\draw[->] (7) to [out=315, in=45] (6);
\draw[->] (8) -- (7);
\draw[->] (9) -- (10);
\draw[->] (9) to [out=315, in=270] (11);
\draw[->] (10) -- (8);
\draw[->] (10) to [out=315, in=225] (11);
\draw[->] (11) to [out=135, in=45] (10);
\end{tikzpicture}\\
L'attracteur final calculé par l'algorithme est donc $Attr_{j_0}^4(F)=Attr_{j_0}^3(F)=Attr_{j_0}(F)=\{1,2,3,4,5,9,10,11\}$\\

\noindent Cet attracteur correspond à l'ensemble gagnant $W_0$ du joueur $j_0$. Par exemple, si le pion est initialement placé sur le sommet $5$, ce sera à $j_0$ de le déplacer. Selon la stratégie gagnante pour le joueur $j_0$ décrite dans la section précédente, celui-ci déplacera le pion vers $3$. Le coup suivant sera décidé par le joueur $j_1$. Celui ci n'aura pas le choix et devra déplacer le pions sur un sommet de $F$ : $1$ ou $2$. Le joueur $j_0$ gagne la partie.\\ L'ensemble $W_1=\{6,7,8\}$ est donc l'ensemble gagnant du joueur $j_1$. Si le pion est initialement placé sur un sommet de cet ensemble, alors $j_1$ gagne. Par exemple, le pion placé initialement sur $6$ sera déplacé par le joueur $j_1$ vers $7$ (en passant éventuellement par $8$ selon la stratégie gagnante pour le joueur $j_1$ car ni $7$ ni $8$ ne font partie de l'attracteur). Le joueur $j_0$ déplacera le pion de $7$ vers $6$ et la partie consistera en une répétition infinie de coups entre $6$, $7$ et $8$.\\

Cet attracteur permet de résoudre un jeu d'atteignabilité avec $F=\{1,2,11\}$ et donc, par le théorème \ref{thm:dualite}, permettrait aussi de résoudre un jeu de sûreté avec comme ensemble de sommets sûrs $G=V\setminus F$ pour le joueur $j_1$.




\chapter{Cas infini}

\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
\renewcommand{\leftmark}{CONCLUSION}

Mettez votre conclusion ici.  Dressez le bilan de votre travail effectué, en prenant du recul. Discuter de si vous avez bien réussi les objectifs du travail ou non. Présentez les perspectives futurs.

\newpage
%Le style bibliographique utilis
\bibliographystyle{latex8}

%Le fichier .bib uitilis
\bibliography{biblio}

\newpage
\appendix
\addcontentsline{toc}{chapter}{Annexes}

\chapter{Premi\`ere annexe}
\renewcommand{\leftmark}{ANNEXE \thechapter.~~Premi\`ere annexe}
\label{annexe1}

\chapter{Deuxi\`eme annexe}
\renewcommand{\leftmark}{ANNEXE \thechapter.~~Deuxi\`eme annexe}
\label{annexe2}

%%%%%%%FIN-ANNEXES%%%%%%%%%%
\end{document}
